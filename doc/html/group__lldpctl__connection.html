<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>lldp: Managing connection to lldpd</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">lldp
   &#160;<span id="projectnumber">0.7.11</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Managing connection to lldpd</div>  </div>
<div class="ingroups"><a class="el" href="group__liblldpctl.html">liblldpctl: library to interface with lldpd</a></div></div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Managing connection to lldpd:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__lldpctl__connection.png" border="0" alt="" usemap="#group____lldpctl____connection"/>
<map name="group____lldpctl____connection" id="group____lldpctl____connection">
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structlldpctl__conn__t.html">lldpctl_conn_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lldpctl__connection.html#ga9df318a1e5daa143591f0931a282c103">lldpctl_conn_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ssize_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lldpctl__connection.html#gabbeeb2e577b5fed6e3ae8f71805845b3">lldpctl_send_callback</a> )(<a class="el" href="structlldpctl__conn__t.html">lldpctl_conn_t</a> *conn, const uint8_t *data, size_t length, void *user_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ssize_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lldpctl__connection.html#gab4d497fd12075fc3960a40330f7f59ed">lldpctl_recv_callback</a> )(<a class="el" href="structlldpctl__conn__t.html">lldpctl_conn_t</a> *conn, const uint8_t *data, size_t length, void *user_data)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lldpctl__connection.html#gae1c0446ba6aa01bfa83e72985f2ab35d">lldpctl_get_default_transport</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lldpctl__connection.html#ga3e25c14b8d805fc248f679befdac6c72">lldpctl_recv</a> (<a class="el" href="structlldpctl__conn__t.html">lldpctl_conn_t</a> *conn, const uint8_t *data, size_t length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lldpctl__connection.html#ga2fc31f5af97ad70b5ea755f690501b3d">lldpctl_send</a> (<a class="el" href="structlldpctl__conn__t.html">lldpctl_conn_t</a> *conn)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lldpctl__connection.html#ga4ab492b59755694bd4a040bebe2558a5">lldpctl_process_conn_buffer</a> (<a class="el" href="structlldpctl__conn__t.html">lldpctl_conn_t</a> *conn)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlldpctl__conn__t.html">lldpctl_conn_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lldpctl__connection.html#gabe60f85d3df83aa2154e5ddd9128ce3d">lldpctl_new</a> (<a class="el" href="group__lldpctl__connection.html#gabbeeb2e577b5fed6e3ae8f71805845b3">lldpctl_send_callback</a> send, <a class="el" href="group__lldpctl__connection.html#gab4d497fd12075fc3960a40330f7f59ed">lldpctl_recv_callback</a> recv, void *user_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlldpctl__conn__t.html">lldpctl_conn_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lldpctl__connection.html#ga1c7b4c392a60b27909e2098209bbdca2">lldpctl_new_name</a> (const char *ctlname, <a class="el" href="group__lldpctl__connection.html#gabbeeb2e577b5fed6e3ae8f71805845b3">lldpctl_send_callback</a> send, <a class="el" href="group__lldpctl__connection.html#gab4d497fd12075fc3960a40330f7f59ed">lldpctl_recv_callback</a> recv, void *user_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__lldpctl__connection.html#gaebd41c3ca7c8b6aa996198a3cea0b3a5">lldpctl_release</a> (<a class="el" href="structlldpctl__conn__t.html">lldpctl_conn_t</a> *conn)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>Connection with lldpd.</p>
<p>This library does not handle IO. They are delegated to a set of functions to allow a user to specify exactly how IO should be done. A user is expected to provide two functions: the first one is called when the library requests incoming data, the other one when it requests outgoing data. Moreover, the user is also expected to call the appropriate functions when data comes back (<a class="el" href="group__lldpctl__connection.html#ga3e25c14b8d805fc248f679befdac6c72">lldpctl_recv()</a>) or needs to be sent (<a class="el" href="group__lldpctl__connection.html#ga2fc31f5af97ad70b5ea755f690501b3d">lldpctl_send()</a>).</p>
<p>Because the most common case is synchronous IO, `liblldpctl` will use classic synchronous IO with the Unix socket if no IO functions are provided by the user. For all other cases, the user must provide the appropriate functions.</p>
<p>A connection should be allocated by using <a class="el" href="group__lldpctl__connection.html#gabe60f85d3df83aa2154e5ddd9128ce3d">lldpctl_new()</a>. It needs to be released with <a class="el" href="group__lldpctl__connection.html#gaebd41c3ca7c8b6aa996198a3cea0b3a5">lldpctl_release()</a>. </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga9df318a1e5daa143591f0931a282c103"></a><!-- doxytag: member="lldpctl.h::lldpctl_conn_t" ref="ga9df318a1e5daa143591f0931a282c103" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structlldpctl__conn__t.html">lldpctl_conn_t</a> <a class="el" href="structlldpctl__conn__t.html">lldpctl_conn_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Structure referencing a connection with lldpd.</p>
<p>This structure should be handled as opaque. It can be allocated with <code><a class="el" href="group__lldpctl__connection.html#gabe60f85d3df83aa2154e5ddd9128ce3d">lldpctl_new()</a></code> and the associated resources will be freed with <code><a class="el" href="group__lldpctl__connection.html#gaebd41c3ca7c8b6aa996198a3cea0b3a5">lldpctl_release()</a></code>. </p>

</div>
</div>
<a class="anchor" id="gab4d497fd12075fc3960a40330f7f59ed"></a><!-- doxytag: member="lldpctl.h::lldpctl_recv_callback" ref="gab4d497fd12075fc3960a40330f7f59ed" args=")(lldpctl_conn_t *conn, const uint8_t *data, size_t length, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* <a class="el" href="group__lldpctl__connection.html#gab4d497fd12075fc3960a40330f7f59ed">lldpctl_recv_callback</a>)(<a class="el" href="structlldpctl__conn__t.html">lldpctl_conn_t</a> *conn, const uint8_t *data, size_t length, void *user_data)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Callback function invoked to receive data from lldpd.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lldpctl</td><td>Handle to the connection to lldpd. </td></tr>
    <tr><td class="paramname">data</td><td>Buffer for receiving data </td></tr>
    <tr><td class="paramname">length</td><td>Maximum bytes we can receive </td></tr>
    <tr><td class="paramname">user_data</td><td>Provided user data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes really received or either <code>LLDPCTL_ERR_WOULDBLOCK</code> if no bytes can be received without blocking, <code>LLDPCTL_ERR_CALLBACK_FAILURE</code> for other errors or <code>LLDPCTL_ERR_EOF</code> if end of file was reached. </dd></dl>

</div>
</div>
<a class="anchor" id="gabbeeb2e577b5fed6e3ae8f71805845b3"></a><!-- doxytag: member="lldpctl.h::lldpctl_send_callback" ref="gabbeeb2e577b5fed6e3ae8f71805845b3" args=")(lldpctl_conn_t *conn, const uint8_t *data, size_t length, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ssize_t(* <a class="el" href="group__lldpctl__connection.html#gabbeeb2e577b5fed6e3ae8f71805845b3">lldpctl_send_callback</a>)(<a class="el" href="structlldpctl__conn__t.html">lldpctl_conn_t</a> *conn, const uint8_t *data, size_t length, void *user_data)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Callback function invoked to send data to lldpd.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lldpctl</td><td>Handle to the connection to lldpd. </td></tr>
    <tr><td class="paramname">data</td><td>Bytes to be sent. </td></tr>
    <tr><td class="paramname">length</td><td>Length of provided data. </td></tr>
    <tr><td class="paramname">user_data</td><td>Provided user data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes really sent or either <code>LLDPCTL_ERR_WOULDBLOCK</code> if no bytes can be sent without blocking or <code>LLDPCTL_ERR_CALLBACK_FAILURE</code> for other errors. </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gae1c0446ba6aa01bfa83e72985f2ab35d"></a><!-- doxytag: member="lldpctl.h::lldpctl_get_default_transport" ref="gae1c0446ba6aa01bfa83e72985f2ab35d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="group__lldpctl__connection.html#gae1c0446ba6aa01bfa83e72985f2ab35d">lldpctl_get_default_transport</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get default transport name.</p>
<p>Currently, this is the default location of the Unix socket. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__lldpctl__connection_gae1c0446ba6aa01bfa83e72985f2ab35d_icgraph.png" border="0" usemap="#group__lldpctl__connection_gae1c0446ba6aa01bfa83e72985f2ab35d_icgraph" alt=""/></div>
<map name="group__lldpctl__connection_gae1c0446ba6aa01bfa83e72985f2ab35d_icgraph" id="group__lldpctl__connection_gae1c0446ba6aa01bfa83e72985f2ab35d_icgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="gabe60f85d3df83aa2154e5ddd9128ce3d"></a><!-- doxytag: member="lldpctl.h::lldpctl_new" ref="gabe60f85d3df83aa2154e5ddd9128ce3d" args="(lldpctl_send_callback send, lldpctl_recv_callback recv, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlldpctl__conn__t.html">lldpctl_conn_t</a>* <a class="el" href="group__lldpctl__connection.html#gabe60f85d3df83aa2154e5ddd9128ce3d">lldpctl_new</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__lldpctl__connection.html#gabbeeb2e577b5fed6e3ae8f71805845b3">lldpctl_send_callback</a>&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lldpctl__connection.html#gab4d497fd12075fc3960a40330f7f59ed">lldpctl_recv_callback</a>&#160;</td>
          <td class="paramname"><em>recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a new handler for connecting to lldpd.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">send</td><td>Callback to be used when sending new data is requested. </td></tr>
    <tr><td class="paramname">recv</td><td>Callback to be used when receiving new data is requested. </td></tr>
    <tr><td class="paramname">user_data</td><td>Data to pass to callbacks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An handler to be used to connect to lldpd or <code>NULL</code> in case of error. In the later case, the error is probable an out of memory condition.</dd></dl>
<p>The allocated handler can be released with <code><a class="el" href="group__lldpctl__connection.html#gaebd41c3ca7c8b6aa996198a3cea0b3a5">lldpctl_release()</a></code>. If the provided parameters are both <code>NULL</code>, default synchronous callbacks will be used. </p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__lldpctl__connection_gabe60f85d3df83aa2154e5ddd9128ce3d_cgraph.png" border="0" usemap="#group__lldpctl__connection_gabe60f85d3df83aa2154e5ddd9128ce3d_cgraph" alt=""/></div>
<map name="group__lldpctl__connection_gabe60f85d3df83aa2154e5ddd9128ce3d_cgraph" id="group__lldpctl__connection_gabe60f85d3df83aa2154e5ddd9128ce3d_cgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga1c7b4c392a60b27909e2098209bbdca2"></a><!-- doxytag: member="lldpctl.h::lldpctl_new_name" ref="ga1c7b4c392a60b27909e2098209bbdca2" args="(const char *ctlname, lldpctl_send_callback send, lldpctl_recv_callback recv, void *user_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlldpctl__conn__t.html">lldpctl_conn_t</a>* <a class="el" href="group__lldpctl__connection.html#ga1c7b4c392a60b27909e2098209bbdca2">lldpctl_new_name</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ctlname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lldpctl__connection.html#gabbeeb2e577b5fed6e3ae8f71805845b3">lldpctl_send_callback</a>&#160;</td>
          <td class="paramname"><em>send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__lldpctl__connection.html#gab4d497fd12075fc3960a40330f7f59ed">lldpctl_recv_callback</a>&#160;</td>
          <td class="paramname"><em>recv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a new handler for connecting to lldpd.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ctlname</td><td>the Unix-domain socket to connect to lldpd. </td></tr>
    <tr><td class="paramname">send</td><td>Callback to be used when sending new data is requested. </td></tr>
    <tr><td class="paramname">recv</td><td>Callback to be used when receiving new data is requested. </td></tr>
    <tr><td class="paramname">user_data</td><td>Data to pass to callbacks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An handler to be used to connect to lldpd or <code>NULL</code> in case of error. In the later case, the error is probable an out of memory condition.</dd></dl>
<p>The allocated handler can be released with <code><a class="el" href="group__lldpctl__connection.html#gaebd41c3ca7c8b6aa996198a3cea0b3a5">lldpctl_release()</a></code>. If the provided parameters are both <code>NULL</code>, default synchronous callbacks will be used. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__lldpctl__connection_ga1c7b4c392a60b27909e2098209bbdca2_icgraph.png" border="0" usemap="#group__lldpctl__connection_ga1c7b4c392a60b27909e2098209bbdca2_icgraph" alt=""/></div>
<map name="group__lldpctl__connection_ga1c7b4c392a60b27909e2098209bbdca2_icgraph" id="group__lldpctl__connection_ga1c7b4c392a60b27909e2098209bbdca2_icgraph">
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga4ab492b59755694bd4a040bebe2558a5"></a><!-- doxytag: member="lldpctl.h::lldpctl_process_conn_buffer" ref="ga4ab492b59755694bd4a040bebe2558a5" args="(lldpctl_conn_t *conn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__lldpctl__connection.html#ga4ab492b59755694bd4a040bebe2558a5">lldpctl_process_conn_buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlldpctl__conn__t.html">lldpctl_conn_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function invoked to see if there's more data to be processed in the buffer.</p>
<p>This function should be invoked to check for notifications in the data that has already been read. Its used typically for asynchronous connections.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Handle to the connection to lldpd. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 to indicate maybe more data is available for processing !0 to indicate no data or insufficient data for processing </dd></dl>

</div>
</div>
<a class="anchor" id="ga3e25c14b8d805fc248f679befdac6c72"></a><!-- doxytag: member="lldpctl.h::lldpctl_recv" ref="ga3e25c14b8d805fc248f679befdac6c72" args="(lldpctl_conn_t *conn, const uint8_t *data, size_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t <a class="el" href="group__lldpctl__connection.html#ga3e25c14b8d805fc248f679befdac6c72">lldpctl_recv</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlldpctl__conn__t.html">lldpctl_conn_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function invoked when additional data is available from lldpd.</p>
<p>This function should be invoked in case of asynchronous IO when new data is available from lldpd (expected or unexpected).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Handle to the connection to lldpd. </td></tr>
    <tr><td class="paramname">data</td><td>Data received from lldpd. </td></tr>
    <tr><td class="paramname">length</td><td>Length of data received. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes available or a negative integer if an error has occurred. 0 is not an error. It usually means that a notification has been processed. </dd></dl>

</div>
</div>
<a class="anchor" id="gaebd41c3ca7c8b6aa996198a3cea0b3a5"></a><!-- doxytag: member="lldpctl.h::lldpctl_release" ref="gaebd41c3ca7c8b6aa996198a3cea0b3a5" args="(lldpctl_conn_t *conn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__lldpctl__connection.html#gaebd41c3ca7c8b6aa996198a3cea0b3a5">lldpctl_release</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlldpctl__conn__t.html">lldpctl_conn_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release resources associated with a connection to lldpd.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Previously allocated handler to a connection to lldpd. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success or a negative integer</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__lldpctl__connection.html#gabe60f85d3df83aa2154e5ddd9128ce3d">lldpctl_new()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2fc31f5af97ad70b5ea755f690501b3d"></a><!-- doxytag: member="lldpctl.h::lldpctl_send" ref="ga2fc31f5af97ad70b5ea755f690501b3d" args="(lldpctl_conn_t *conn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t <a class="el" href="group__lldpctl__connection.html#ga2fc31f5af97ad70b5ea755f690501b3d">lldpctl_send</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlldpctl__conn__t.html">lldpctl_conn_t</a> *&#160;</td>
          <td class="paramname"><em>conn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Function invoked when there is an opportunity to send data to lldpd.</p>
<p>This function should be invoked in case of asynchronous IO when new data can be written to lldpd.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">conn</td><td>Handle to the connection to lldpd. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes processed or a negative integer if an error has occured. </dd></dl>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 17 2014 22:16:07 for lldp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
