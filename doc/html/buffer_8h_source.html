<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>lldp: /home/evan/lldpd-0.7.11/libevent/include/event2/buffer.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">lldp
   &#160;<span id="projectnumber">0.7.11</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/evan/lldpd-0.7.11/libevent/include/event2/buffer.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="buffer_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<a name="l00005"></a>00005 <span class="comment"> * modification, are permitted provided that the following conditions</span>
<a name="l00006"></a>00006 <span class="comment"> * are met:</span>
<a name="l00007"></a>00007 <span class="comment"> * 1. Redistributions of source code must retain the above copyright</span>
<a name="l00008"></a>00008 <span class="comment"> *    notice, this list of conditions and the following disclaimer.</span>
<a name="l00009"></a>00009 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<a name="l00010"></a>00010 <span class="comment"> *    notice, this list of conditions and the following disclaimer in the</span>
<a name="l00011"></a>00011 <span class="comment"> *    documentation and/or other materials provided with the distribution.</span>
<a name="l00012"></a>00012 <span class="comment"> * 3. The name of the author may not be used to endorse or promote products</span>
<a name="l00013"></a>00013 <span class="comment"> *    derived from this software without specific prior written permission.</span>
<a name="l00014"></a>00014 <span class="comment"> *</span>
<a name="l00015"></a>00015 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&#39;&#39; AND ANY EXPRESS OR</span>
<a name="l00016"></a>00016 <span class="comment"> * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
<a name="l00017"></a>00017 <span class="comment"> * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00018"></a>00018 <span class="comment"> * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<a name="l00019"></a>00019 <span class="comment"> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</span>
<a name="l00020"></a>00020 <span class="comment"> * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<a name="l00021"></a>00021 <span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<a name="l00022"></a>00022 <span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<a name="l00023"></a>00023 <span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
<a name="l00024"></a>00024 <span class="comment"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00025"></a>00025 <span class="comment"> */</span>
<a name="l00026"></a>00026 <span class="preprocessor">#ifndef _EVENT2_BUFFER_H_</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span><span class="preprocessor">#define _EVENT2_BUFFER_H_</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span>
<a name="l00075"></a>00075 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
<a name="l00077"></a>00077 <span class="preprocessor">#endif</span>
<a name="l00078"></a>00078 <span class="preprocessor"></span>
<a name="l00079"></a>00079 <span class="preprocessor">#include &lt;event2/event-config.h&gt;</span>
<a name="l00080"></a>00080 <span class="preprocessor">#include &lt;stdarg.h&gt;</span>
<a name="l00081"></a>00081 <span class="preprocessor">#ifdef _EVENT_HAVE_SYS_TYPES_H</span>
<a name="l00082"></a>00082 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00083"></a>00083 <span class="preprocessor">#endif</span>
<a name="l00084"></a>00084 <span class="preprocessor"></span><span class="preprocessor">#ifdef _EVENT_HAVE_SYS_UIO_H</span>
<a name="l00085"></a>00085 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/uio.h&gt;</span>
<a name="l00086"></a>00086 <span class="preprocessor">#endif</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="util_8h.html">event2/util.h</a>&gt;</span>
<a name="l00088"></a>00088 
<a name="l00095"></a>00095 <span class="keyword">struct </span><a class="code" href="structevbuffer.html">evbuffer</a>
<a name="l00096"></a>00096 #ifdef _EVENT_IN_DOXYGEN
<a name="l00097"></a>00097 {}
<a name="l00098"></a>00098 <span class="preprocessor">#endif</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span>;
<a name="l00100"></a>00100 
<a name="l00109"></a>00109 <span class="keyword">struct </span><a class="code" href="structevbuffer__ptr.html">evbuffer_ptr</a> {
<a name="l00110"></a>00110         ev_ssize_t pos;
<a name="l00111"></a>00111 
<a name="l00112"></a>00112         <span class="comment">/* Do not alter the values of fields. */</span>
<a name="l00113"></a>00113         <span class="keyword">struct </span>{
<a name="l00114"></a>00114                 <span class="keywordtype">void</span> *chain;
<a name="l00115"></a>00115                 <span class="keywordtype">size_t</span> pos_in_chain;
<a name="l00116"></a>00116         } _internal;
<a name="l00117"></a>00117 };
<a name="l00118"></a>00118 
<a name="l00124"></a>00124 <span class="preprocessor">#ifdef _EVENT_HAVE_SYS_UIO_H</span>
<a name="l00125"></a><a class="code" href="structevbuffer__iovec.html">00125</a> <span class="preprocessor"></span><span class="preprocessor">#define evbuffer_iovec iovec</span>
<a name="l00126"></a>00126 <span class="preprocessor"></span><span class="comment">/* Internal use -- defined only if we are using the native struct iovec */</span>
<a name="l00127"></a><a class="code" href="structevbuffer__iovec.html#ae9880e88c5e12cf1ca9319f20782c8ea">00127</a> <span class="preprocessor">#define _EVBUFFER_IOVEC_IS_NATIVE</span>
<a name="l00128"></a>00128 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00129"></a><a class="code" href="structevbuffer__iovec.html#afcd13900daf65022414ae14a8af166f6">00129</a> <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structevbuffer__iovec.html">evbuffer_iovec</a> {
<a name="l00131"></a>00131         <span class="keywordtype">void</span> *<a class="code" href="structevbuffer__iovec.html#ae9880e88c5e12cf1ca9319f20782c8ea">iov_base</a>;
<a name="l00133"></a>00133         <span class="keywordtype">size_t</span> <a class="code" href="structevbuffer__iovec.html#afcd13900daf65022414ae14a8af166f6">iov_len</a>;
<a name="l00134"></a>00134 };
<a name="l00135"></a>00135 <span class="preprocessor">#endif</span>
<a name="l00136"></a>00136 <span class="preprocessor"></span>
<a name="l00143"></a>00143 <span class="keyword">struct </span><a class="code" href="structevbuffer.html">evbuffer</a> *evbuffer_new(<span class="keywordtype">void</span>);
<a name="l00149"></a>00149 <span class="keywordtype">void</span> evbuffer_free(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf);
<a name="l00150"></a>00150 
<a name="l00163"></a>00163 <span class="keywordtype">int</span> evbuffer_enable_locking(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf, <span class="keywordtype">void</span> *<a class="code" href="structevbuffer.html#a100fdaedb8eb0d56fd262e7ea2930930">lock</a>);
<a name="l00164"></a>00164 
<a name="l00169"></a>00169 <span class="keywordtype">void</span> evbuffer_lock(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf);
<a name="l00170"></a>00170 
<a name="l00175"></a>00175 <span class="keywordtype">void</span> evbuffer_unlock(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf);
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 
<a name="l00193"></a>00193 <span class="preprocessor">#define EVBUFFER_FLAG_DRAINS_TO_FD 1</span>
<a name="l00194"></a>00194 <span class="preprocessor"></span>
<a name="l00202"></a>00202 <span class="keywordtype">int</span> evbuffer_set_flags(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf, ev_uint64_t <a class="code" href="structevbuffer.html#a46fb11e4f55160a35cb5e6113300d864">flags</a>);
<a name="l00210"></a>00210 <span class="keywordtype">int</span> evbuffer_clear_flags(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf, ev_uint64_t <a class="code" href="structevbuffer.html#a46fb11e4f55160a35cb5e6113300d864">flags</a>);
<a name="l00211"></a>00211 
<a name="l00218"></a>00218 <span class="keywordtype">size_t</span> evbuffer_get_length(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf);
<a name="l00219"></a>00219 
<a name="l00232"></a>00232 <span class="keywordtype">size_t</span> evbuffer_get_contiguous_space(<span class="keyword">const</span> <span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf);
<a name="l00233"></a>00233 
<a name="l00244"></a>00244 <span class="keywordtype">int</span> evbuffer_expand(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf, <span class="keywordtype">size_t</span> datlen);
<a name="l00245"></a>00245 
<a name="l00279"></a>00279 <span class="keywordtype">int</span>
<a name="l00280"></a>00280 evbuffer_reserve_space(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf, ev_ssize_t size,
<a name="l00281"></a>00281     <span class="keyword">struct</span> <a class="code" href="structevbuffer__iovec.html">evbuffer_iovec</a> *vec, <span class="keywordtype">int</span> n_vec);
<a name="l00282"></a>00282 
<a name="l00304"></a>00304 <span class="keywordtype">int</span> evbuffer_commit_space(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf,
<a name="l00305"></a>00305     <span class="keyword">struct</span> <a class="code" href="structevbuffer__iovec.html">evbuffer_iovec</a> *vec, <span class="keywordtype">int</span> n_vecs);
<a name="l00306"></a>00306 
<a name="l00315"></a>00315 <span class="keywordtype">int</span> evbuffer_add(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">size_t</span> datlen);
<a name="l00316"></a>00316 
<a name="l00317"></a>00317 
<a name="l00329"></a>00329 <span class="keywordtype">int</span> evbuffer_remove(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf, <span class="keywordtype">void</span> *data, <span class="keywordtype">size_t</span> datlen);
<a name="l00330"></a>00330 
<a name="l00342"></a>00342 ev_ssize_t evbuffer_copyout(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf, <span class="keywordtype">void</span> *data_out, <span class="keywordtype">size_t</span> datlen);
<a name="l00343"></a>00343 
<a name="l00357"></a>00357 <span class="keywordtype">int</span> evbuffer_remove_buffer(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *src, <span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *dst,
<a name="l00358"></a><a class="code" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178">00358</a>     <span class="keywordtype">size_t</span> datlen);
<a name="l00359"></a>00359 
<a name="l00362"></a>00362 <span class="keyword">enum</span> <a class="code" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178">evbuffer_eol_style</a> {
<a name="l00372"></a>00372         <a class="code" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178ab7c6da1408b1b2ec3a6657e5a71a50c3">EVBUFFER_EOL_ANY</a>,
<a name="l00375"></a><a class="code" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178ac572ea90e5a96a7ceb878f2a8ef48993">00375</a>         <a class="code" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178a4aec5353e85fbb57ce3b1ee68f36f641">EVBUFFER_EOL_CRLF</a>,
<a name="l00377"></a>00377         <a class="code" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178a814775b4a9773d34421e7e88ca8c58de">EVBUFFER_EOL_CRLF_STRICT</a>,
<a name="l00379"></a>00379         <a class="code" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178ac572ea90e5a96a7ceb878f2a8ef48993">EVBUFFER_EOL_LF</a>
<a name="l00380"></a>00380 };
<a name="l00381"></a>00381 
<a name="l00396"></a>00396 <span class="keywordtype">char</span> *evbuffer_readln(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buffer, <span class="keywordtype">size_t</span> *n_read_out,
<a name="l00397"></a>00397     <span class="keyword">enum</span> <a class="code" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178">evbuffer_eol_style</a> eol_style);
<a name="l00398"></a>00398 
<a name="l00411"></a>00411 <span class="keywordtype">int</span> evbuffer_add_buffer(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *outbuf, <span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *inbuf);
<a name="l00412"></a>00412 
<a name="l00419"></a>00419 <span class="keyword">typedef</span> void (*<a class="code" href="buffer_8h.html#acc4dead0032a38143cb2c902417f9177">evbuffer_ref_cleanup_cb</a>)(<span class="keyword">const</span> <span class="keywordtype">void</span> *data,
<a name="l00420"></a>00420     <span class="keywordtype">size_t</span> datalen, <span class="keywordtype">void</span> *extra);
<a name="l00421"></a>00421 
<a name="l00437"></a>00437 <span class="keywordtype">int</span> evbuffer_add_reference(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *outbuf,
<a name="l00438"></a>00438     <span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">size_t</span> datlen,
<a name="l00439"></a>00439     <a class="code" href="buffer_8h.html#acc4dead0032a38143cb2c902417f9177">evbuffer_ref_cleanup_cb</a> cleanupfn, <span class="keywordtype">void</span> *cleanupfn_arg);
<a name="l00440"></a>00440 
<a name="l00462"></a>00462 <span class="keywordtype">int</span> evbuffer_add_file(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *outbuf, <span class="keywordtype">int</span> fd, ev_off_t offset,
<a name="l00463"></a>00463     ev_off_t length);
<a name="l00464"></a>00464 
<a name="l00477"></a>00477 <span class="keywordtype">int</span> evbuffer_add_printf(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...)
<a name="l00478"></a>00478 <span class="preprocessor">#ifdef __GNUC__</span>
<a name="l00479"></a>00479 <span class="preprocessor"></span>  __attribute__((format(printf, 2, 3)))
<a name="l00480"></a>00480 <span class="preprocessor">#endif</span>
<a name="l00481"></a>00481 <span class="preprocessor"></span>;
<a name="l00482"></a>00482 
<a name="l00491"></a>00491 <span class="keywordtype">int</span> evbuffer_add_vprintf(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, va_list ap)
<a name="l00492"></a>00492 <span class="preprocessor">#ifdef __GNUC__</span>
<a name="l00493"></a>00493 <span class="preprocessor"></span>        __attribute__((format(printf, 2, 0)))
<a name="l00494"></a>00494 <span class="preprocessor">#endif</span>
<a name="l00495"></a>00495 <span class="preprocessor"></span>;
<a name="l00496"></a>00496 
<a name="l00497"></a>00497 
<a name="l00505"></a>00505 <span class="keywordtype">int</span> evbuffer_drain(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf, <span class="keywordtype">size_t</span> len);
<a name="l00506"></a>00506 
<a name="l00507"></a>00507 
<a name="l00518"></a>00518 <span class="keywordtype">int</span> evbuffer_write(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buffer, <a class="code" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> fd);
<a name="l00519"></a>00519 
<a name="l00532"></a>00532 <span class="keywordtype">int</span> evbuffer_write_atmost(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buffer, <a class="code" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> fd,
<a name="l00533"></a>00533                                                   ev_ssize_t howmuch);
<a name="l00534"></a>00534 
<a name="l00544"></a>00544 <span class="keywordtype">int</span> evbuffer_read(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buffer, <a class="code" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> fd, <span class="keywordtype">int</span> howmuch);
<a name="l00545"></a>00545 
<a name="l00557"></a>00557 <span class="keyword">struct </span><a class="code" href="structevbuffer__ptr.html">evbuffer_ptr</a> evbuffer_search(struct <a class="code" href="structevbuffer.html">evbuffer</a> *buffer, <span class="keyword">const</span> <span class="keywordtype">char</span> *what, <span class="keywordtype">size_t</span> len, <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structevbuffer__ptr.html">evbuffer_ptr</a> *start);
<a name="l00558"></a>00558 
<a name="l00573"></a>00573 <span class="keyword">struct </span><a class="code" href="structevbuffer__ptr.html">evbuffer_ptr</a> evbuffer_search_range(struct <a class="code" href="structevbuffer.html">evbuffer</a> *buffer, <span class="keyword">const</span> <span class="keywordtype">char</span> *what, <span class="keywordtype">size_t</span> len, <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structevbuffer__ptr.html">evbuffer_ptr</a> *start, <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structevbuffer__ptr.html">evbuffer_ptr</a> *end);
<a name="l00574"></a>00574 
<a name="l00579"></a>00579 <span class="keyword">enum</span> <a class="code" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014">evbuffer_ptr_how</a> {
<a name="l00582"></a>00582         <a class="code" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014a78a0ff3721ff5f1647f743dcfb2f13ee">EVBUFFER_PTR_SET</a>,
<a name="l00584"></a>00584         <a class="code" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014a0bce00d78b5fbc55c478ff362269f428">EVBUFFER_PTR_ADD</a>
<a name="l00585"></a>00585 };
<a name="l00586"></a>00586 
<a name="l00599"></a>00599 <span class="keywordtype">int</span>
<a name="l00600"></a>00600 evbuffer_ptr_set(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buffer, <span class="keyword">struct</span> <a class="code" href="structevbuffer__ptr.html">evbuffer_ptr</a> *ptr,
<a name="l00601"></a>00601     <span class="keywordtype">size_t</span> position, <span class="keyword">enum</span> <a class="code" href="buffer_8h.html#a13a9ee759900ce2964d16acd5f309014">evbuffer_ptr_how</a> how);
<a name="l00602"></a>00602 
<a name="l00617"></a>00617 <span class="keyword">struct </span><a class="code" href="structevbuffer__ptr.html">evbuffer_ptr</a> evbuffer_search_eol(struct <a class="code" href="structevbuffer.html">evbuffer</a> *buffer,
<a name="l00618"></a>00618     <span class="keyword">struct </span><a class="code" href="structevbuffer__ptr.html">evbuffer_ptr</a> *start, <span class="keywordtype">size_t</span> *eol_len_out,
<a name="l00619"></a>00619     <span class="keyword">enum</span> <a class="code" href="buffer_8h.html#ad8daf54669a1d2094ce4251dbb502178">evbuffer_eol_style</a> eol_style);
<a name="l00620"></a>00620 
<a name="l00649"></a>00649 <span class="keywordtype">int</span> evbuffer_peek(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buffer, ev_ssize_t len,
<a name="l00650"></a>00650     <span class="keyword">struct</span> <a class="code" href="structevbuffer__ptr.html">evbuffer_ptr</a> *start_at,
<a name="l00651"></a>00651     <span class="keyword">struct</span> <a class="code" href="structevbuffer__iovec.html">evbuffer_iovec</a> *vec_out, <span class="keywordtype">int</span> n_vec);
<a name="l00652"></a>00652 
<a name="l00653"></a>00653 
<a name="l00658"></a>00658 <span class="keyword">struct </span><a class="code" href="structevbuffer__cb__info.html">evbuffer_cb_info</a> {
<a name="l00661"></a><a class="code" href="structevbuffer__cb__info.html#a54993c52358fe66682374e534a926255">00661</a>         <span class="keywordtype">size_t</span> <a class="code" href="structevbuffer__cb__info.html#ad2a73f9e156151abc7c3f126aa3d1df4">orig_size</a>;
<a name="l00663"></a>00663         <span class="keywordtype">size_t</span> <a class="code" href="structevbuffer__cb__info.html#a3c94ebcaf499c58bbb1e8ebdfe59fbc1">n_added</a>;
<a name="l00665"></a>00665         <span class="keywordtype">size_t</span> <a class="code" href="structevbuffer__cb__info.html#a54993c52358fe66682374e534a926255">n_deleted</a>;
<a name="l00666"></a>00666 };
<a name="l00667"></a>00667 
<a name="l00687"></a>00687 <span class="keyword">typedef</span> void (*<a class="code" href="buffer_8h.html#af40adaa98b02da7fca55da29270266d9">evbuffer_cb_func</a>)(<span class="keyword">struct </span><a class="code" href="structevbuffer.html">evbuffer</a> *buffer, <span class="keyword">const</span> <span class="keyword">struct </span><a class="code" href="structevbuffer__cb__info.html">evbuffer_cb_info</a> *info, <span class="keywordtype">void</span> *arg);
<a name="l00688"></a>00688 
<a name="l00689"></a>00689 <span class="keyword">struct </span><a class="code" href="structevbuffer__cb__entry.html">evbuffer_cb_entry</a>;
<a name="l00701"></a>00701 <span class="keyword">struct </span><a class="code" href="structevbuffer__cb__entry.html">evbuffer_cb_entry</a> *evbuffer_add_cb(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buffer, <a class="code" href="buffer_8h.html#af40adaa98b02da7fca55da29270266d9">evbuffer_cb_func</a> <a class="code" href="structevbuffer__cb__entry.html#ab0092556c7b5a9c75126e4ae79bd0f84">cb</a>, <span class="keywordtype">void</span> *<a class="code" href="structevbuffer__cb__entry.html#aafd3d1a6343925cb274875556a6faa0e">cbarg</a>);
<a name="l00702"></a>00702 
<a name="l00711"></a>00711 <span class="keywordtype">int</span> evbuffer_remove_cb_entry(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buffer,
<a name="l00712"></a>00712                              <span class="keyword">struct</span> <a class="code" href="structevbuffer__cb__entry.html">evbuffer_cb_entry</a> *ent);
<a name="l00713"></a>00713 
<a name="l00720"></a>00720 <span class="keywordtype">int</span> evbuffer_remove_cb(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buffer, <a class="code" href="buffer_8h.html#af40adaa98b02da7fca55da29270266d9">evbuffer_cb_func</a> <a class="code" href="structevbuffer__cb__entry.html#ab0092556c7b5a9c75126e4ae79bd0f84">cb</a>, <span class="keywordtype">void</span> *<a class="code" href="structevbuffer__cb__entry.html#aafd3d1a6343925cb274875556a6faa0e">cbarg</a>);
<a name="l00721"></a>00721 
<a name="l00727"></a>00727 <span class="preprocessor">#define EVBUFFER_CB_ENABLED 1</span>
<a name="l00728"></a>00728 <span class="preprocessor"></span>
<a name="l00736"></a>00736 <span class="keywordtype">int</span> evbuffer_cb_set_flags(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buffer,
<a name="l00737"></a>00737                           <span class="keyword">struct</span> <a class="code" href="structevbuffer__cb__entry.html">evbuffer_cb_entry</a> *<a class="code" href="structevbuffer__cb__entry.html#ab0092556c7b5a9c75126e4ae79bd0f84">cb</a>, ev_uint32_t <a class="code" href="structevbuffer__cb__entry.html#a46fb11e4f55160a35cb5e6113300d864">flags</a>);
<a name="l00738"></a>00738 
<a name="l00746"></a>00746 <span class="keywordtype">int</span> evbuffer_cb_clear_flags(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buffer,
<a name="l00747"></a>00747                           <span class="keyword">struct</span> <a class="code" href="structevbuffer__cb__entry.html">evbuffer_cb_entry</a> *<a class="code" href="structevbuffer__cb__entry.html#ab0092556c7b5a9c75126e4ae79bd0f84">cb</a>, ev_uint32_t <a class="code" href="structevbuffer__cb__entry.html#a46fb11e4f55160a35cb5e6113300d864">flags</a>);
<a name="l00748"></a>00748 
<a name="l00749"></a>00749 <span class="preprocessor">#if 0</span>
<a name="l00750"></a>00750 <span class="preprocessor"></span>
<a name="l00759"></a>00759 <span class="keywordtype">void</span> evbuffer_cb_suspend(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buffer, <span class="keyword">struct</span> <a class="code" href="structevbuffer__cb__entry.html">evbuffer_cb_entry</a> *<a class="code" href="structevbuffer__cb__entry.html#ab0092556c7b5a9c75126e4ae79bd0f84">cb</a>);
<a name="l00768"></a>00768 <span class="keywordtype">void</span> evbuffer_cb_unsuspend(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buffer, <span class="keyword">struct</span> <a class="code" href="structevbuffer__cb__entry.html">evbuffer_cb_entry</a> *<a class="code" href="structevbuffer__cb__entry.html#ab0092556c7b5a9c75126e4ae79bd0f84">cb</a>);
<a name="l00769"></a>00769 <span class="preprocessor">#endif</span>
<a name="l00770"></a>00770 <span class="preprocessor"></span>
<a name="l00780"></a>00780 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *evbuffer_pullup(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf, ev_ssize_t size);
<a name="l00781"></a>00781 
<a name="l00791"></a>00791 <span class="keywordtype">int</span> evbuffer_prepend(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf, <span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">size_t</span> size);
<a name="l00792"></a>00792 
<a name="l00801"></a>00801 <span class="keywordtype">int</span> evbuffer_prepend_buffer(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *dst, <span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a>* src);
<a name="l00802"></a>00802 
<a name="l00817"></a>00817 <span class="keywordtype">int</span> evbuffer_freeze(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf, <span class="keywordtype">int</span> at_front);
<a name="l00826"></a>00826 <span class="keywordtype">int</span> evbuffer_unfreeze(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf, <span class="keywordtype">int</span> at_front);
<a name="l00827"></a>00827 
<a name="l00828"></a>00828 <span class="keyword">struct </span><a class="code" href="structevent__base.html">event_base</a>;
<a name="l00836"></a>00836 <span class="keywordtype">int</span> evbuffer_defer_callbacks(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buffer, <span class="keyword">struct</span> <a class="code" href="structevent__base.html">event_base</a> *base);
<a name="l00837"></a>00837 
<a name="l00838"></a>00838 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00839"></a>00839 <span class="preprocessor"></span>}
<a name="l00840"></a>00840 <span class="preprocessor">#endif</span>
<a name="l00841"></a>00841 <span class="preprocessor"></span>
<a name="l00842"></a>00842 <span class="preprocessor">#endif </span><span class="comment">/* _EVENT2_BUFFER_H_ */</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 17 2014 22:16:06 for lldp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
