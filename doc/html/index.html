<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>lldp: Main Page</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">lldp
   &#160;<span id="projectnumber">0.7.11</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">lldp Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="intro"></a>
Introduction</h2>
<p>Libevent is an event notification library for developing scalable network servers. The Libevent API provides a mechanism to execute a callback function when a specific event occurs on a file descriptor or after a timeout has been reached. Furthermore, Libevent also support callbacks due to signals or regular timeouts.</p>
<p>Libevent is meant to replace the event loop found in event driven network servers. An application just needs to call <a class="el" href="event__compat_8h.html#a1f4991bceb8aaf33545d1fc857230b51">event_dispatch()</a> and then add or remove events dynamically without having to change the event loop.</p>
<p>Currently, Libevent supports /dev/poll, kqueue(2), select(2), poll(2), epoll(4), and evports. The internal event mechanism is completely independent of the exposed event API, and a simple update of Libevent can provide new functionality without having to redesign the applications. As a result, Libevent allows for portable application development and provides the most scalable event notification mechanism available on an operating system. Libevent can also be used for multithreaded programs. Libevent should compile on Linux, *BSD, Mac OS X, Solaris and, Windows.</p>
<h2><a class="anchor" id="usage"></a>
Standard usage</h2>
<p>Every program that uses Libevent must inclurde the &lt;<a class="el" href="include_2event2_2event_8h.html">event2/event.h</a>&gt; header, and pass the -levent flag to the linker. (You can instead link -levent_core if you only want the main event and buffered IO-based code, and don't want to link any protocol code.)</p>
<h2><a class="anchor" id="setup"></a>
Library setup</h2>
<p>Before you call any other Libevent functions, you need to set up the library. If you're going to use Libevent from multiple threads in a multithreaded application, you need to initialize thread support -- typically by using evthread_use_pthreads() or evthread_use_windows_threads(). See &lt;<a class="el" href="thread_8h.html">event2/thread.h</a>&gt; for more information.</p>
<p>This is also the point where you can replace Libevent's memory management functions with event_set_mem_functions, and enable debug mode with <a class="el" href="include_2event2_2event_8h.html#a3472400b8b1802550df2242673a6da37">event_enable_debug_mode()</a>.</p>
<h2><a class="anchor" id="base"></a>
Creating an event base</h2>
<p>Next, you need to create an <a class="el" href="structevent__base.html">event_base</a> structure, using <a class="el" href="include_2event2_2event_8h.html#a4c16f1203aebc67f94791ae0240b7353">event_base_new()</a> or <a class="el" href="include_2event2_2event_8h.html#a444afb106c45ba296d847417a3a1ef04">event_base_new_with_config()</a>. The <a class="el" href="structevent__base.html">event_base</a> is responsible for keeping track of which events are "pending" (that is to say, being watched to see if they become active) and which events are "active". Every event is associated with a single <a class="el" href="structevent__base.html">event_base</a>.</p>
<h2><a class="anchor" id="event"></a>
Event notification</h2>
<p>For each file descriptor that you wish to monitor, you must create an event structure with <a class="el" href="include_2event2_2event_8h.html#ab9a66f828d205eda84b321e32014cbbd">event_new()</a>. (You may also declare an event structure and call <a class="el" href="include_2event2_2event_8h.html#afade5e4859dee5b85d502e5594a05cf0">event_assign()</a> to initialize the members of the structure.) To enable notification, you add the structure to the list of monitored events by calling <a class="el" href="include_2event2_2event_8h.html#a44df7b40859b56f2c866adb02dabdd9e">event_add()</a>. The event structure must remain allocated as long as it is active, so it should generally be allocated on the heap.</p>
<h2><a class="anchor" id="loop"></a>
Dispaching evets.</h2>
<p>Finally, you call <a class="el" href="include_2event2_2event_8h.html#a01e457364ed5216a8c7bc219033b946f">event_base_dispatch()</a> to loop and dispatch events. You can also use <a class="el" href="include_2event2_2event_8h.html#ad712706e6a763b6662f0eb03b3d8cd80">event_base_loop()</a> for more fine-grained control.</p>
<p>Currently, only one thread can be dispatching a given <a class="el" href="structevent__base.html">event_base</a> at a time. If you want to run events in multiple threads at once, you can either have a single <a class="el" href="structevent__base.html">event_base</a> whose events add work to a work queue, or you can create multiple <a class="el" href="structevent__base.html">event_base</a> objects.</p>
<h2><a class="anchor" id="bufferevent"></a>
I/O Buffers</h2>
<p>Libevent provides a buffered I/O abstraction on top of the regular event callbacks. This abstraction is called a bufferevent. A bufferevent provides input and output buffers that get filled and drained automatically. The user of a buffered event no longer deals directly with the I/O, but instead is reading from input and writing to output buffers.</p>
<p>Once initialized via <a class="el" href="bufferevent_8h.html#a501557193aa56c9f4923583d9d734395">bufferevent_socket_new()</a>, the bufferevent structure can be used repeatedly with <a class="el" href="bufferevent_8h.html#a1b9a3412e8c8e122c745b33d46b9643e">bufferevent_enable()</a> and <a class="el" href="bufferevent_8h.html#aa15582fe250247aa98d4897527215727">bufferevent_disable()</a>. Instead of reading and writing directly to a socket, you would call <a class="el" href="bufferevent_8h.html#a6bd435529e20a39b24fead9ddcd966ba">bufferevent_read()</a> and <a class="el" href="bufferevent_8h.html#abc606695cd6bb2e3f25c4330d0c9e3ab">bufferevent_write()</a>.</p>
<p>When read enabled the bufferevent will try to read from the file descriptor and call the read callback. The write callback is executed whenever the output buffer is drained below the write low watermark, which is 0 by default.</p>
<p>See &lt;event2/bufferevent*.h&gt; for more information.</p>
<h2><a class="anchor" id="timers"></a>
Timers</h2>
<p>Libevent can also be used to create timers that invoke a callback after a certain amount of time has expired. The evtimer_new() function returns an event struct to use as a timer. To activate the timer, call evtimer_add(). Timers can be deactivated by calling evtimer_del().</p>
<h2><a class="anchor" id="evdns"></a>
Asynchronous DNS resolution</h2>
<p>Libevent provides an asynchronous DNS resolver that should be used instead of the standard DNS resolver functions. See the &lt;<a class="el" href="dns_8h.html">event2/dns.h</a>&gt; functions for more detail.</p>
<h2><a class="anchor" id="evhttp"></a>
Event-driven HTTP servers</h2>
<p>Libevent provides a very simple event-driven HTTP server that can be embedded in your program and used to service HTTP requests.</p>
<p>To use this capability, you need to include the &lt;<a class="el" href="http_8h.html">event2/http.h</a>&gt; header in your program. See that header for more information.</p>
<h2><a class="anchor" id="evrpc"></a>
A framework for RPC servers and clients</h2>
<p>Libevent provides a framework for creating RPC servers and clients. It takes care of marshaling and unmarshaling all data structures.</p>
<h2><a class="anchor" id="api"></a>
API Reference</h2>
<p>To browse the complete documentation of the libevent API, click on any of the following links.</p>
<p><a class="el" href="include_2event2_2event_8h.html">event2/event.h</a> The primary libevent header</p>
<p><a class="el" href="thread_8h.html">event2/thread.h</a> Functions for use by multithreaded programs</p>
<p><a class="el" href="buffer_8h.html">event2/buffer.h</a> and <a class="el" href="bufferevent_8h.html">event2/bufferevent.h</a> Buffer management for network reading and writing</p>
<p><a class="el" href="util_8h.html">event2/util.h</a> Utility functions for portable nonblocking network code</p>
<p><a class="el" href="dns_8h.html">event2/dns.h</a> Asynchronous DNS resolution</p>
<p><a class="el" href="http_8h.html">event2/http.h</a> An embedded libevent-based HTTP server</p>
<p><a class="el" href="rpc_8h.html">event2/rpc.h</a> A framework for creating RPC servers and clients </p>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 17 2014 22:16:08 for lldp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
