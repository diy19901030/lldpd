<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>lldp: /home/evan/lldpd-0.7.11/libevent/include/event2/thread.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">lldp
   &#160;<span id="projectnumber">0.7.11</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">/home/evan/lldpd-0.7.11/libevent/include/event2/thread.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;event2/event-config.h&gt;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for thread.h:</div>
<div class="dyncontent">
<div class="center"><img src="thread_8h__incl.png" border="0" usemap="#_2home_2evan_2lldpd-0_87_811_2libevent_2include_2event2_2thread_8h" alt=""/></div>
<map name="_2home_2evan_2lldpd-0_87_811_2libevent_2include_2event2_2thread_8h" id="_2home_2evan_2lldpd-0_87_811_2libevent_2include_2event2_2thread_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="thread_8h__dep__incl.png" border="0" usemap="#_2home_2evan_2lldpd-0_87_811_2libevent_2include_2event2_2thread_8hdep" alt=""/></div>
<map name="_2home_2evan_2lldpd-0_87_811_2libevent_2include_2event2_2thread_8hdep" id="_2home_2evan_2lldpd-0_87_811_2libevent_2include_2event2_2thread_8hdep">
</map>
</div>
</div>
<p><a href="thread_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevthread__lock__callbacks.html">evthread_lock_callbacks</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structevthread__condition__callbacks.html">evthread_condition_callbacks</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a911771b77b303b553612bef600573448"></a><!-- doxytag: member="thread.h::EVTHREAD_LOCK_API_VERSION" ref="a911771b77b303b553612bef600573448" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVTHREAD_LOCK_API_VERSION</b>&#160;&#160;&#160;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83fecb8503fdb40ca4e57bac66608721"></a><!-- doxytag: member="thread.h::EVTHREAD_CONDITION_API_VERSION" ref="a83fecb8503fdb40ca4e57bac66608721" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVTHREAD_CONDITION_API_VERSION</b>&#160;&#160;&#160;1</td></tr>
<tr><td colspan="2"><div class="groupHeader">Flags passed to lock functions</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aa9fb1861f3b09a03c5986561dd00db0d">EVTHREAD_WRITE</a>&#160;&#160;&#160;0x04</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a8c7a3fb4b1f521b4a262e5043f3fa14c">EVTHREAD_READ</a>&#160;&#160;&#160;0x08</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a746e63692bf5bd5b4ee5d929df1592e2">EVTHREAD_TRY</a>&#160;&#160;&#160;0x10</td></tr>
<tr><td colspan="2"><div class="groupHeader">Types of locks</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a8fbf4020f11c3b98459fd8d4d427513c">EVTHREAD_LOCKTYPE_RECURSIVE</a>&#160;&#160;&#160;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefbfdb33065b9e3a50e69c7c02cf2f42"></a><!-- doxytag: member="thread.h::EVTHREAD_LOCKTYPE_READWRITE" ref="aefbfdb33065b9e3a50e69c7c02cf2f42" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>EVTHREAD_LOCKTYPE_READWRITE</b>&#160;&#160;&#160;2</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a89fd5de575d5f0fba24d0e8e0a25c641">evthread_set_lock_callbacks</a> (const struct <a class="el" href="structevthread__lock__callbacks.html">evthread_lock_callbacks</a> *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a05b941ee76d9798da61270d4016bb015">evthread_set_condition_callbacks</a> (const struct <a class="el" href="structevthread__condition__callbacks.html">evthread_condition_callbacks</a> *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a3eae2571d33fc83f16d1810ab56211d3">evthread_set_id_callback</a> (unsigned long(*id_fn)(void))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a473ab66bfe6a74fe78eb95a86053ae67">evthread_enable_lock_debuging</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ad6ce3b3efff53b41758944a8b486f62c">evthread_make_base_notifiable</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Functions for multi-threaded applications using Libevent.</p>
<p>When using a multi-threaded application in which multiple threads add and delete events from a single event base, Libevent needs to lock its data structures.</p>
<p>Like the memory-management function hooks, all of the threading functions _must_ be set up before an <a class="el" href="structevent__base.html">event_base</a> is created if you want the base to use them.</p>
<p>Most programs will either be using Windows threads or Posix threads. You can configure Libevent to use one of these event_use_windows_threads() or event_use_pthreads() respectively. If you're using another threading library, you'll need to configure threading functions manually using <a class="el" href="thread_8h.html#a89fd5de575d5f0fba24d0e8e0a25c641">evthread_set_lock_callbacks()</a> and <a class="el" href="thread_8h.html#a05b941ee76d9798da61270d4016bb015">evthread_set_condition_callbacks()</a>. </p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a8fbf4020f11c3b98459fd8d4d427513c"></a><!-- doxytag: member="thread.h::EVTHREAD_LOCKTYPE_RECURSIVE" ref="a8fbf4020f11c3b98459fd8d4d427513c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="thread_8h.html#a8fbf4020f11c3b98459fd8d4d427513c">EVTHREAD_LOCKTYPE_RECURSIVE</a>&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A recursive lock is one that can be acquired multiple times at once by the same thread. No other process can allocate the lock until the thread that has been holding it has unlocked it as many times as it locked it. </p>

</div>
</div>
<a class="anchor" id="a8c7a3fb4b1f521b4a262e5043f3fa14c"></a><!-- doxytag: member="thread.h::EVTHREAD_READ" ref="a8c7a3fb4b1f521b4a262e5043f3fa14c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="thread_8h.html#a8c7a3fb4b1f521b4a262e5043f3fa14c">EVTHREAD_READ</a>&#160;&#160;&#160;0x08</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A flag passed to a locking callback when the lock was allocated as a read-write lock, and we want to acquire or release the lock for reading. </p>

</div>
</div>
<a class="anchor" id="a746e63692bf5bd5b4ee5d929df1592e2"></a><!-- doxytag: member="thread.h::EVTHREAD_TRY" ref="a746e63692bf5bd5b4ee5d929df1592e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="thread_8h.html#a746e63692bf5bd5b4ee5d929df1592e2">EVTHREAD_TRY</a>&#160;&#160;&#160;0x10</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A flag passed to a locking callback when we don't want to block waiting for the lock; if we can't get the lock immediately, we will instead return nonzero from the locking callback. </p>

</div>
</div>
<a class="anchor" id="aa9fb1861f3b09a03c5986561dd00db0d"></a><!-- doxytag: member="thread.h::EVTHREAD_WRITE" ref="aa9fb1861f3b09a03c5986561dd00db0d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="thread_8h.html#aa9fb1861f3b09a03c5986561dd00db0d">EVTHREAD_WRITE</a>&#160;&#160;&#160;0x04</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A flag passed to a locking callback when the lock was allocated as a read-write lock, and we want to acquire or release the lock for writing. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a473ab66bfe6a74fe78eb95a86053ae67"></a><!-- doxytag: member="thread.h::evthread_enable_lock_debuging" ref="a473ab66bfe6a74fe78eb95a86053ae67" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="thread_8h.html#a473ab66bfe6a74fe78eb95a86053ae67">evthread_enable_lock_debuging</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable debugging wrappers around the current lock callbacks. If Libevent makes one of several common locking errors, exit with an assertion failure.</p>
<p>If you're going to call this function, you must do so before any locks are allocated. </p>

</div>
</div>
<a class="anchor" id="ad6ce3b3efff53b41758944a8b486f62c"></a><!-- doxytag: member="thread.h::evthread_make_base_notifiable" ref="ad6ce3b3efff53b41758944a8b486f62c" args="(struct event_base *base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="thread_8h.html#ad6ce3b3efff53b41758944a8b486f62c">evthread_make_base_notifiable</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make sure it's safe to tell an event base to wake up from another thread or a signal handler.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a05b941ee76d9798da61270d4016bb015"></a><!-- doxytag: member="thread.h::evthread_set_condition_callbacks" ref="a05b941ee76d9798da61270d4016bb015" args="(const struct evthread_condition_callbacks *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="thread_8h.html#a05b941ee76d9798da61270d4016bb015">evthread_set_condition_callbacks</a> </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevthread__condition__callbacks.html">evthread_condition_callbacks</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets a group of functions that Libevent should use for condition variables. For full information on the required callback API, see the documentation for the individual members of <a class="el" href="structevthread__condition__callbacks.html">evthread_condition_callbacks</a>.</p>
<p>Note that if you're using Windows or the Pthreads threading library, you probably shouldn't call this function; instead, use evthread_use_windows_threads() or evthread_use_pthreads() if you can. </p>

</div>
</div>
<a class="anchor" id="a3eae2571d33fc83f16d1810ab56211d3"></a><!-- doxytag: member="thread.h::evthread_set_id_callback" ref="a3eae2571d33fc83f16d1810ab56211d3" args="(unsigned long(*id_fn)(void))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="thread_8h.html#a3eae2571d33fc83f16d1810ab56211d3">evthread_set_id_callback</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned long(*)(void)&#160;</td>
          <td class="paramname"><em>id_fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the function for determining the thread id.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the event base for which to set the id function </td></tr>
    <tr><td class="paramname">id_fn</td><td>the identify function Libevent should invoke to determine the identity of a thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89fd5de575d5f0fba24d0e8e0a25c641"></a><!-- doxytag: member="thread.h::evthread_set_lock_callbacks" ref="a89fd5de575d5f0fba24d0e8e0a25c641" args="(const struct evthread_lock_callbacks *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="thread_8h.html#a89fd5de575d5f0fba24d0e8e0a25c641">evthread_set_lock_callbacks</a> </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structevthread__lock__callbacks.html">evthread_lock_callbacks</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets a group of functions that Libevent should use for locking. For full information on the required callback API, see the documentation for the individual members of <a class="el" href="structevthread__lock__callbacks.html">evthread_lock_callbacks</a>.</p>
<p>Note that if you're using Windows or the Pthreads threading library, you probably shouldn't call this function; instead, use evthread_use_windows_threads() or evthread_use_posix_threads() if you can. </p>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 17 2014 22:16:07 for lldp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
