<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>lldp: /home/evan/lldpd-0.7.11/libevent/evbuffer-internal.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">lldp
   &#160;<span id="projectnumber">0.7.11</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">/home/evan/lldpd-0.7.11/libevent/evbuffer-internal.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright (c) 2000-2007 Niels Provos &lt;provos@citi.umich.edu&gt;</span>
<a name="l00003"></a>00003 <span class="comment"> * Copyright (c) 2007-2012 Niels Provos and Nick Mathewson</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<a name="l00006"></a>00006 <span class="comment"> * modification, are permitted provided that the following conditions</span>
<a name="l00007"></a>00007 <span class="comment"> * are met:</span>
<a name="l00008"></a>00008 <span class="comment"> * 1. Redistributions of source code must retain the above copyright</span>
<a name="l00009"></a>00009 <span class="comment"> *    notice, this list of conditions and the following disclaimer.</span>
<a name="l00010"></a>00010 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright</span>
<a name="l00011"></a>00011 <span class="comment"> *    notice, this list of conditions and the following disclaimer in the</span>
<a name="l00012"></a>00012 <span class="comment"> *    documentation and/or other materials provided with the distribution.</span>
<a name="l00013"></a>00013 <span class="comment"> * 3. The name of the author may not be used to endorse or promote products</span>
<a name="l00014"></a>00014 <span class="comment"> *    derived from this software without specific prior written permission.</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS&#39;&#39; AND ANY EXPRESS OR</span>
<a name="l00017"></a>00017 <span class="comment"> * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
<a name="l00018"></a>00018 <span class="comment"> * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.</span>
<a name="l00019"></a>00019 <span class="comment"> * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,</span>
<a name="l00020"></a>00020 <span class="comment"> * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT</span>
<a name="l00021"></a>00021 <span class="comment"> * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<a name="l00022"></a>00022 <span class="comment"> * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<a name="l00023"></a>00023 <span class="comment"> * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<a name="l00024"></a>00024 <span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF</span>
<a name="l00025"></a>00025 <span class="comment"> * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00026"></a>00026 <span class="comment"> */</span>
<a name="l00027"></a>00027 <span class="preprocessor">#ifndef _EVBUFFER_INTERNAL_H_</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span><span class="preprocessor">#define _EVBUFFER_INTERNAL_H_</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span>
<a name="l00030"></a>00030 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
<a name="l00032"></a>00032 <span class="preprocessor">#endif</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;event2/event-config.h&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="util_8h.html">event2/util.h</a>&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;util-internal.h&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;defer-internal.h&quot;</span>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="comment">/* Experimental cb flag: &quot;never deferred.&quot;  Implementation note:</span>
<a name="l00040"></a>00040 <span class="comment"> * these callbacks may get an inaccurate view of n_del/n_added in their</span>
<a name="l00041"></a>00041 <span class="comment"> * arguments. */</span>
<a name="l00042"></a>00042 <span class="preprocessor">#define EVBUFFER_CB_NODEFER 2</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span>
<a name="l00044"></a>00044 <span class="preprocessor">#ifdef WIN32</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="preprocessor">#include &lt;winsock2.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#endif</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/queue.h&gt;</span>
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <span class="comment">/* Minimum allocation for a chain.  We define this so that we&#39;re burning no</span>
<a name="l00050"></a>00050 <span class="comment"> * more than 5% of each allocation on overhead.  It would be nice to lose even</span>
<a name="l00051"></a>00051 <span class="comment"> * less space, though. */</span>
<a name="l00052"></a>00052 <span class="preprocessor">#if _EVENT_SIZEOF_VOID_P &lt; 8</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span><span class="preprocessor">#define MIN_BUFFER_SIZE 512</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span><span class="preprocessor">#define MIN_BUFFER_SIZE 1024</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span>
<a name="l00060"></a><a class="code" href="structevbuffer__cb__entry.html">00060</a> <span class="keyword">struct </span><a class="code" href="structevbuffer__cb__entry.html">evbuffer_cb_entry</a> {
<a name="l00062"></a>00062         <a class="code" href="structevbuffer__cb__entry.html#afea9027864f627c6216f6fb2145d786f">TAILQ_ENTRY</a>(<a class="code" href="structevbuffer__cb__entry.html">evbuffer_cb_entry</a>) next;
<a name="l00066"></a>00066         <span class="keyword">union </span>{
<a name="l00067"></a>00067                 <a class="code" href="buffer_8h.html#af40adaa98b02da7fca55da29270266d9">evbuffer_cb_func</a> cb_func;
<a name="l00068"></a>00068                 <a class="code" href="buffer__compat_8h.html#a613068ef7e1be05deead9c9b6f021158">evbuffer_cb</a> cb_obsolete;
<a name="l00069"></a>00069         } <a class="code" href="structevbuffer__cb__entry.html#ab0092556c7b5a9c75126e4ae79bd0f84">cb</a>;
<a name="l00071"></a><a class="code" href="structevbuffer__cb__entry.html#aafd3d1a6343925cb274875556a6faa0e">00071</a>         <span class="keywordtype">void</span> *<a class="code" href="structevbuffer__cb__entry.html#aafd3d1a6343925cb274875556a6faa0e">cbarg</a>;
<a name="l00073"></a><a class="code" href="structevbuffer__cb__entry.html#a46fb11e4f55160a35cb5e6113300d864">00073</a>         ev_uint32_t <a class="code" href="structevbuffer__cb__entry.html#a46fb11e4f55160a35cb5e6113300d864">flags</a>;
<a name="l00074"></a>00074 };
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 <span class="keyword">struct </span><a class="code" href="structbufferevent.html">bufferevent</a>;
<a name="l00077"></a>00077 <span class="keyword">struct </span><a class="code" href="structevbuffer__chain.html">evbuffer_chain</a>;
<a name="l00078"></a><a class="code" href="structevbuffer.html">00078</a> <span class="keyword">struct </span><a class="code" href="structevbuffer.html">evbuffer</a> {
<a name="l00080"></a><a class="code" href="structevbuffer.html#ae5d4dd177b7c4ab8e5addfde55a843d0">00080</a>         <span class="keyword">struct </span><a class="code" href="structevbuffer__chain.html">evbuffer_chain</a> *<a class="code" href="structevbuffer.html#ae5d4dd177b7c4ab8e5addfde55a843d0">first</a>;
<a name="l00082"></a><a class="code" href="structevbuffer.html#a4abfabd53365959da29b2dc10105ba2f">00082</a>         <span class="keyword">struct </span><a class="code" href="structevbuffer__chain.html">evbuffer_chain</a> *<a class="code" href="structevbuffer.html#a4abfabd53365959da29b2dc10105ba2f">last</a>;
<a name="l00083"></a>00083 
<a name="l00097"></a><a class="code" href="structevbuffer.html#a4f345dcb623a0aa38ef1080010f77b43">00097</a>         <span class="keyword">struct </span><a class="code" href="structevbuffer__chain.html">evbuffer_chain</a> **<a class="code" href="structevbuffer.html#a4f345dcb623a0aa38ef1080010f77b43">last_with_datap</a>;
<a name="l00098"></a>00098 
<a name="l00100"></a><a class="code" href="structevbuffer.html#aa117fc7f9adae4a74d56508b20f7de1f">00100</a>         <span class="keywordtype">size_t</span> <a class="code" href="structevbuffer.html#aa117fc7f9adae4a74d56508b20f7de1f">total_len</a>;
<a name="l00101"></a>00101 
<a name="l00104"></a><a class="code" href="structevbuffer.html#a9df4902363fb7de91d4c716a81f69ede">00104</a>         <span class="keywordtype">size_t</span> <a class="code" href="structevbuffer.html#a9df4902363fb7de91d4c716a81f69ede">n_add_for_cb</a>;
<a name="l00107"></a><a class="code" href="structevbuffer.html#a3a01f211a034cdcbe3a857faae8f06e4">00107</a>         <span class="keywordtype">size_t</span> <a class="code" href="structevbuffer.html#a3a01f211a034cdcbe3a857faae8f06e4">n_del_for_cb</a>;
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 <span class="preprocessor">#ifndef _EVENT_DISABLE_THREAD_SUPPORT</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span>
<a name="l00111"></a><a class="code" href="structevbuffer.html#a100fdaedb8eb0d56fd262e7ea2930930">00111</a>         <span class="keywordtype">void</span> *<a class="code" href="structevbuffer.html#a100fdaedb8eb0d56fd262e7ea2930930">lock</a>;
<a name="l00112"></a>00112 <span class="preprocessor">#endif</span>
<a name="l00113"></a>00113 <span class="preprocessor"></span>
<a name="l00115"></a><a class="code" href="structevbuffer.html#a5f18976d54ba259145f3c86cec07e65b">00115</a>         <span class="keywordtype">unsigned</span> <a class="code" href="structevbuffer.html#a5f18976d54ba259145f3c86cec07e65b">own_lock</a> : 1;
<a name="l00118"></a><a class="code" href="structevbuffer.html#af1193eaa1bdcb77eaa7b3329b2e85b78">00118</a>         <span class="keywordtype">unsigned</span> <a class="code" href="structevbuffer.html#af1193eaa1bdcb77eaa7b3329b2e85b78">freeze_start</a> : 1;
<a name="l00121"></a><a class="code" href="structevbuffer.html#a164d26e2922717053aa1dad7e21bc0d6">00121</a>         <span class="keywordtype">unsigned</span> <a class="code" href="structevbuffer.html#a164d26e2922717053aa1dad7e21bc0d6">freeze_end</a> : 1;
<a name="l00127"></a><a class="code" href="structevbuffer.html#ab66179bcc649255321e2cbf198bf00b2">00127</a>         <span class="keywordtype">unsigned</span> <a class="code" href="structevbuffer.html#ab66179bcc649255321e2cbf198bf00b2">deferred_cbs</a> : 1;
<a name="l00128"></a>00128 <span class="preprocessor">#ifdef WIN32</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span>
<a name="l00130"></a>00130         <span class="keywordtype">unsigned</span> is_overlapped : 1;
<a name="l00131"></a>00131 <span class="preprocessor">#endif</span>
<a name="l00132"></a>00132 <span class="preprocessor"></span>
<a name="l00133"></a><a class="code" href="structevbuffer.html#a46fb11e4f55160a35cb5e6113300d864">00133</a>         ev_uint32_t <a class="code" href="structevbuffer.html#a46fb11e4f55160a35cb5e6113300d864">flags</a>;
<a name="l00134"></a>00134 
<a name="l00136"></a><a class="code" href="structevbuffer.html#aef0be26b7399af631600db6b35df19fb">00136</a>         <span class="keyword">struct </span><a class="code" href="structdeferred__cb__queue.html">deferred_cb_queue</a> *<a class="code" href="structevbuffer.html#aef0be26b7399af631600db6b35df19fb">cb_queue</a>;
<a name="l00137"></a>00137 
<a name="l00142"></a><a class="code" href="structevbuffer.html#afc0873ec70fe10be301b3ec811a1d6e5">00142</a>         <span class="keywordtype">int</span> <a class="code" href="structevbuffer.html#afc0873ec70fe10be301b3ec811a1d6e5">refcnt</a>;
<a name="l00143"></a>00143 
<a name="l00146"></a><a class="code" href="structevbuffer.html#aebe8e3d0c896b175676d2a8ab6c9c725">00146</a>         <span class="keyword">struct </span><a class="code" href="structdeferred__cb.html">deferred_cb</a> <a class="code" href="structevbuffer.html#aebe8e3d0c896b175676d2a8ab6c9c725">deferred</a>;
<a name="l00147"></a>00147 
<a name="l00149"></a>00149         <a class="code" href="structevbuffer.html#a7db680df1bef97e57e10e5e7baa31ebf">TAILQ_HEAD</a>(evbuffer_cb_queue, <a class="code" href="structevbuffer__cb__entry.html">evbuffer_cb_entry</a>) callbacks;
<a name="l00150"></a>00150 
<a name="l00153"></a><a class="code" href="structevbuffer.html#af196e0fec9c6301947f81adcbae449c2">00153</a>         struct <a class="code" href="structbufferevent.html">bufferevent</a> *<a class="code" href="structevbuffer.html#af196e0fec9c6301947f81adcbae449c2">parent</a>;
<a name="l00154"></a>00154 };
<a name="l00155"></a>00155 
<a name="l00157"></a><a class="code" href="structevbuffer__chain.html">00157</a> struct <a class="code" href="structevbuffer__chain.html">evbuffer_chain</a> {
<a name="l00159"></a><a class="code" href="structevbuffer__chain.html#a747cab9940afc2ee7fdfa05b1d0e1b36">00159</a>         <span class="keyword">struct </span>evbuffer_chain *<a class="code" href="structevbuffer__chain.html#a747cab9940afc2ee7fdfa05b1d0e1b36">next</a>;
<a name="l00160"></a>00160 
<a name="l00162"></a><a class="code" href="structevbuffer__chain.html#a6bfa135ea1282c77528701bbb081ed06">00162</a>         <span class="keywordtype">size_t</span> <a class="code" href="structevbuffer__chain.html#a6bfa135ea1282c77528701bbb081ed06">buffer_len</a>;
<a name="l00163"></a>00163 
<a name="l00166"></a><a class="code" href="structevbuffer__chain.html#a17dd937c4e81426858da22165d740a8f">00166</a>         ev_off_t <a class="code" href="structevbuffer__chain.html#a17dd937c4e81426858da22165d740a8f">misalign</a>;
<a name="l00167"></a>00167 
<a name="l00171"></a><a class="code" href="structevbuffer__chain.html#a9536cbff2e1f5e767a86a07627dac302">00171</a>         <span class="keywordtype">size_t</span> <a class="code" href="structevbuffer__chain.html#a9536cbff2e1f5e767a86a07627dac302">off</a>;
<a name="l00172"></a>00172 
<a name="l00174"></a><a class="code" href="structevbuffer__chain.html#a8b08a4d2ec878257d64c55f64a62242c">00174</a>         <span class="keywordtype">unsigned</span> <a class="code" href="structevbuffer__chain.html#a8b08a4d2ec878257d64c55f64a62242c">flags</a>;
<a name="l00175"></a>00175 <span class="preprocessor">#define EVBUFFER_MMAP           0x0001  </span>
<a name="l00176"></a>00176 <span class="preprocessor">#define EVBUFFER_SENDFILE       0x0002  </span>
<a name="l00177"></a>00177 <span class="preprocessor">#define EVBUFFER_REFERENCE      0x0004  </span>
<a name="l00178"></a>00178 <span class="preprocessor">#define EVBUFFER_IMMUTABLE      0x0008  </span>
<a name="l00181"></a>00181 <span class="preprocessor">#define EVBUFFER_MEM_PINNED_R   0x0010</span>
<a name="l00182"></a>00182 <span class="preprocessor"></span><span class="preprocessor">#define EVBUFFER_MEM_PINNED_W   0x0020</span>
<a name="l00183"></a>00183 <span class="preprocessor"></span><span class="preprocessor">#define EVBUFFER_MEM_PINNED_ANY (EVBUFFER_MEM_PINNED_R|EVBUFFER_MEM_PINNED_W)</span>
<a name="l00184"></a>00184 <span class="preprocessor"></span>
<a name="l00186"></a>00186 <span class="preprocessor">#define EVBUFFER_DANGLING       0x0040</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span>
<a name="l00194"></a><a class="code" href="structevbuffer__chain.html#a70e7ad2e1a45c8db5fba9ad4778bd400">00194</a>         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<a class="code" href="structevbuffer__chain.html#a70e7ad2e1a45c8db5fba9ad4778bd400">buffer</a>;
<a name="l00195"></a>00195 };
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 <span class="comment">/* this is currently used by both mmap and sendfile */</span>
<a name="l00198"></a>00198 <span class="comment">/* TODO(niels): something strange needs to happen for Windows here, I am not</span>
<a name="l00199"></a>00199 <span class="comment"> * sure what that is, but it needs to get looked into.</span>
<a name="l00200"></a>00200 <span class="comment"> */</span>
<a name="l00201"></a><a class="code" href="structevbuffer__chain__fd.html">00201</a> <span class="keyword">struct </span><a class="code" href="structevbuffer__chain__fd.html">evbuffer_chain_fd</a> {
<a name="l00202"></a><a class="code" href="structevbuffer__chain__fd.html#a6f8059414f0228f0256115e024eeed4b">00202</a>         <span class="keywordtype">int</span> <a class="code" href="structevbuffer__chain__fd.html#a6f8059414f0228f0256115e024eeed4b">fd</a>; 
<a name="l00203"></a>00203 };
<a name="l00204"></a>00204 
<a name="l00207"></a><a class="code" href="structevbuffer__chain__reference.html">00207</a> <span class="keyword">struct </span><a class="code" href="structevbuffer__chain__reference.html">evbuffer_chain_reference</a> {
<a name="l00208"></a>00208         <a class="code" href="buffer_8h.html#acc4dead0032a38143cb2c902417f9177">evbuffer_ref_cleanup_cb</a> cleanupfn;
<a name="l00209"></a>00209         <span class="keywordtype">void</span> *extra;
<a name="l00210"></a>00210 };
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 <span class="preprocessor">#define EVBUFFER_CHAIN_SIZE sizeof(struct evbuffer_chain)</span>
<a name="l00213"></a>00213 <span class="preprocessor"></span>
<a name="l00214"></a>00214 <span class="preprocessor">#define EVBUFFER_CHAIN_EXTRA(t, c) (t *)((struct evbuffer_chain *)(c) + 1)</span>
<a name="l00215"></a>00215 <span class="preprocessor"></span>
<a name="l00217"></a>00217 <span class="preprocessor">#define ASSERT_EVBUFFER_LOCKED(buffer)                  \</span>
<a name="l00218"></a>00218 <span class="preprocessor">        EVLOCK_ASSERT_LOCKED((buffer)-&gt;lock)</span>
<a name="l00219"></a>00219 <span class="preprocessor"></span>
<a name="l00220"></a>00220 <span class="preprocessor">#define EVBUFFER_LOCK(buffer)                                           \</span>
<a name="l00221"></a>00221 <span class="preprocessor">        do {                                                            \</span>
<a name="l00222"></a>00222 <span class="preprocessor">                EVLOCK_LOCK((buffer)-&gt;lock, 0);                         \</span>
<a name="l00223"></a>00223 <span class="preprocessor">        } while (0)</span>
<a name="l00224"></a>00224 <span class="preprocessor"></span><span class="preprocessor">#define EVBUFFER_UNLOCK(buffer)                                         \</span>
<a name="l00225"></a>00225 <span class="preprocessor">        do {                                                            \</span>
<a name="l00226"></a>00226 <span class="preprocessor">                EVLOCK_UNLOCK((buffer)-&gt;lock, 0);                       \</span>
<a name="l00227"></a>00227 <span class="preprocessor">        } while (0)</span>
<a name="l00228"></a>00228 <span class="preprocessor"></span><span class="preprocessor">#define EVBUFFER_LOCK2(buffer1, buffer2)                                \</span>
<a name="l00229"></a>00229 <span class="preprocessor">        do {                                                            \</span>
<a name="l00230"></a>00230 <span class="preprocessor">                EVLOCK_LOCK2((buffer1)-&gt;lock, (buffer2)-&gt;lock, 0, 0);   \</span>
<a name="l00231"></a>00231 <span class="preprocessor">        } while (0)</span>
<a name="l00232"></a>00232 <span class="preprocessor"></span><span class="preprocessor">#define EVBUFFER_UNLOCK2(buffer1, buffer2)                              \</span>
<a name="l00233"></a>00233 <span class="preprocessor">        do {                                                            \</span>
<a name="l00234"></a>00234 <span class="preprocessor">                EVLOCK_UNLOCK2((buffer1)-&gt;lock, (buffer2)-&gt;lock, 0, 0); \</span>
<a name="l00235"></a>00235 <span class="preprocessor">        } while (0)</span>
<a name="l00236"></a>00236 <span class="preprocessor"></span>
<a name="l00238"></a>00238 <span class="keywordtype">void</span> _evbuffer_incref(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf);
<a name="l00240"></a>00240 <span class="keywordtype">void</span> _evbuffer_incref_and_lock(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf);
<a name="l00243"></a>00243 <span class="keywordtype">void</span> _evbuffer_chain_pin(<span class="keyword">struct</span> <a class="code" href="structevbuffer__chain.html">evbuffer_chain</a> *chain, <span class="keywordtype">unsigned</span> flag);
<a name="l00245"></a>00245 <span class="keywordtype">void</span> _evbuffer_chain_unpin(<span class="keyword">struct</span> <a class="code" href="structevbuffer__chain.html">evbuffer_chain</a> *chain, <span class="keywordtype">unsigned</span> flag);
<a name="l00248"></a>00248 <span class="keywordtype">void</span> _evbuffer_decref_and_unlock(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buffer);
<a name="l00249"></a>00249 
<a name="l00252"></a>00252 <span class="keywordtype">int</span> _evbuffer_expand_fast(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *, <span class="keywordtype">size_t</span>, <span class="keywordtype">int</span>);
<a name="l00253"></a>00253 
<a name="l00260"></a>00260 <span class="keywordtype">int</span> _evbuffer_read_setup_vecs(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf, ev_ssize_t howmuch,
<a name="l00261"></a>00261     <span class="keyword">struct</span> <a class="code" href="structevbuffer__iovec.html">evbuffer_iovec</a> *vecs, <span class="keywordtype">int</span> n_vecs, <span class="keyword">struct</span> <a class="code" href="structevbuffer__chain.html">evbuffer_chain</a> ***chainp,
<a name="l00262"></a>00262     <span class="keywordtype">int</span> exact);
<a name="l00263"></a>00263 
<a name="l00264"></a>00264 <span class="comment">/* Helper macro: copies an evbuffer_iovec in ei to a win32 WSABUF in i. */</span>
<a name="l00265"></a>00265 <span class="preprocessor">#define WSABUF_FROM_EVBUFFER_IOV(i,ei) do {             \</span>
<a name="l00266"></a>00266 <span class="preprocessor">                (i)-&gt;buf = (ei)-&gt;iov_base;              \</span>
<a name="l00267"></a>00267 <span class="preprocessor">                (i)-&gt;len = (unsigned long)(ei)-&gt;iov_len;        \</span>
<a name="l00268"></a>00268 <span class="preprocessor">        } while (0)</span>
<a name="l00269"></a>00269 <span class="preprocessor"></span><span class="comment">/* XXXX the cast above is safe for now, but not if we allow mmaps on win64.</span>
<a name="l00270"></a>00270 <span class="comment"> * See note in buffer_iocp&#39;s launch_write function */</span>
<a name="l00271"></a>00271 
<a name="l00273"></a>00273 <span class="keywordtype">void</span> evbuffer_set_parent(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf, <span class="keyword">struct</span> <a class="code" href="structbufferevent.html">bufferevent</a> *bev);
<a name="l00274"></a>00274 
<a name="l00275"></a>00275 <span class="keywordtype">void</span> evbuffer_invoke_callbacks(<span class="keyword">struct</span> <a class="code" href="structevbuffer.html">evbuffer</a> *buf);
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00278"></a>00278 <span class="preprocessor"></span>}
<a name="l00279"></a>00279 <span class="preprocessor">#endif</span>
<a name="l00280"></a>00280 <span class="preprocessor"></span>
<a name="l00281"></a>00281 <span class="preprocessor">#endif </span><span class="comment">/* _EVBUFFER_INTERNAL_H_ */</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 17 2014 22:16:05 for lldp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
