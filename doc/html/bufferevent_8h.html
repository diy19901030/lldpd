<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>lldp: /home/evan/lldpd-0.7.11/libevent/include/event2/bufferevent.h File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">lldp
   &#160;<span id="projectnumber">0.7.11</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">/home/evan/lldpd-0.7.11/libevent/include/event2/bufferevent.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;event2/event-config.h&gt;</code><br/>
<code>#include &lt;<a class="el" href="util_8h_source.html">event2/util.h</a>&gt;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for bufferevent.h:</div>
<div class="dyncontent">
<div class="center"><img src="bufferevent_8h__incl.png" border="0" usemap="#_2home_2evan_2lldpd-0_87_811_2libevent_2include_2event2_2bufferevent_8h" alt=""/></div>
<map name="_2home_2evan_2lldpd-0_87_811_2libevent_2include_2event2_2bufferevent_8h" id="_2home_2evan_2lldpd-0_87_811_2libevent_2include_2event2_2bufferevent_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="bufferevent_8h__dep__incl.png" border="0" usemap="#_2home_2evan_2lldpd-0_87_811_2libevent_2include_2event2_2bufferevent_8hdep" alt=""/></div>
<map name="_2home_2evan_2lldpd-0_87_811_2libevent_2include_2event2_2bufferevent_8hdep" id="_2home_2evan_2lldpd-0_87_811_2libevent_2include_2event2_2bufferevent_8hdep">
</map>
</div>
</div>
<p><a href="bufferevent_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a78fc86349f408552be0fdf249db673ec">EV_RATE_LIMIT_MAX</a>&#160;&#160;&#160;EV_SSIZE_MAX</td></tr>
<tr><td colspan="2"><div class="groupHeader">Bufferevent event codes</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These flags are passed as arguments to a bufferevent's event callback. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a504816ca8678e4f3d0bee2700fda524d">BEV_EVENT_READING</a>&#160;&#160;&#160;0x01</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a557afaa0ce75e6bbb71fdcd68c35d077">BEV_EVENT_WRITING</a>&#160;&#160;&#160;0x02</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a4d7d8c93cf62e6f3d37c0cbac75aebcc">BEV_EVENT_EOF</a>&#160;&#160;&#160;0x10</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a5f112d7a064258bdabf8d5182a3bf5e4">BEV_EVENT_ERROR</a>&#160;&#160;&#160;0x20</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#aa537428e3ac2c8d2dbb4ec041f09347f">BEV_EVENT_TIMEOUT</a>&#160;&#160;&#160;0x40</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#affb7a7e5e21e1541ba6f43f950d92993">BEV_EVENT_CONNECTED</a>&#160;&#160;&#160;0x80</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a75e8fa059136e13c04c237e9c03cdbe8">bufferevent_data_cb</a> )(struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev, void *ctx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a79b5f4b983f8e67005416738c6494ac6">bufferevent_event_cb</a> )(struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev, short what, void *ctx)</td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#aa4919449c62c6483e2d135509190dc65">bufferevent_options</a> { <a class="el" href="bufferevent_8h.html#aa4919449c62c6483e2d135509190dc65a5dc89d74ef445da33295d00c8f6adc90">BEV_OPT_CLOSE_ON_FREE</a> =  (1&lt;&lt;0), 
<a class="el" href="bufferevent_8h.html#aa4919449c62c6483e2d135509190dc65adfb637881b739eff1441ad848a5e3a2d">BEV_OPT_THREADSAFE</a> =  (1&lt;&lt;1), 
<a class="el" href="bufferevent_8h.html#aa4919449c62c6483e2d135509190dc65a2fbeb24d0156aa2492c23aaace73f1d3">BEV_OPT_DEFER_CALLBACKS</a> =  (1&lt;&lt;2), 
<a class="el" href="bufferevent_8h.html#aa4919449c62c6483e2d135509190dc65acb8ca6f6422fb8f9a748521cf8c4caf5">BEV_OPT_UNLOCK_CALLBACKS</a> =  (1&lt;&lt;3)
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#ac35edc760057a2e48b4e8ba9ecf2ad25">bufferevent_flush_mode</a> { <a class="el" href="bufferevent_8h.html#ac35edc760057a2e48b4e8ba9ecf2ad25a81903ce04ca68ac1680dd0b7a28a7fce">BEV_NORMAL</a> =  0, 
<a class="el" href="bufferevent_8h.html#ac35edc760057a2e48b4e8ba9ecf2ad25a77e7f15a95815dcaaef27fdabb0e6164">BEV_FLUSH</a> =  1, 
<a class="el" href="bufferevent_8h.html#ac35edc760057a2e48b4e8ba9ecf2ad25acb248a91854bbebd773061df7f4bbc94">BEV_FINISHED</a> =  2
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a501557193aa56c9f4923583d9d734395">bufferevent_socket_new</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, <a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> fd, int options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#ac2ecbb906883ea848f7bca767d479a2a">bufferevent_socket_connect</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *, struct sockaddr *, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a797686b522045aefb217c6b87ea7ae4a">bufferevent_socket_connect_hostname</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *, struct <a class="el" href="structevdns__base.html">evdns_base</a> *, int, const char *, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a9a66b02bce652cdbcc7d26636ce26d67">bufferevent_socket_get_dns_error</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a0697dabdb9b4057ae71b40a2f0e45fed">bufferevent_base_set</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a5cabb56040b43ba1a92efd21c4a89890">bufferevent_get_base</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a73e1daaa7c4d52c95b16c9944fa62e90">bufferevent_priority_set</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, int pri)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a474a4cef8fd80bea09a636b5f3055bec">bufferevent_free</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a63792519cb94a38beccb5e1390cd6198">bufferevent_setcb</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, <a class="el" href="bufferevent_8h.html#a75e8fa059136e13c04c237e9c03cdbe8">bufferevent_data_cb</a> readcb, <a class="el" href="bufferevent_8h.html#a75e8fa059136e13c04c237e9c03cdbe8">bufferevent_data_cb</a> writecb, <a class="el" href="bufferevent_8h.html#a79b5f4b983f8e67005416738c6494ac6">bufferevent_event_cb</a> eventcb, void *cbarg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a0a367e404942c11265bfcd0b693aa120">bufferevent_setfd</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, <a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> fd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#aa959659c8ba1c56c3444b5c147762a91">bufferevent_getfd</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a8d40fb7aea3c48e25d616bbe4b0fda65">bufferevent_get_underlying</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#abc606695cd6bb2e3f25c4330d0c9e3ab">bufferevent_write</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, const void *data, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a3b140a32a4d16c402433130dc8c3bde4">bufferevent_write_buffer</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a6bd435529e20a39b24fead9ddcd966ba">bufferevent_read</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, void *data, size_t size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#ab2246fd48085c1acc9e98747a83af041">bufferevent_read_buffer</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, struct <a class="el" href="structevbuffer.html">evbuffer</a> *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a7bc716ede3a5fc1e9107ae522e545e0c">bufferevent_get_input</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#af3dea057c5a276461dd94a1601682be1">bufferevent_get_output</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a1b9a3412e8c8e122c745b33d46b9643e">bufferevent_enable</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, short <a class="el" href="structevent.html">event</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#aa15582fe250247aa98d4897527215727">bufferevent_disable</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, short <a class="el" href="structevent.html">event</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#afbb4adabeb188cc9000bdee4ba23bdb2">bufferevent_get_enabled</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a3686d744e67e9a530ebf8ab888ade2cf">bufferevent_set_timeouts</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, const struct timeval *timeout_read, const struct timeval *timeout_write)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a74e3835e99f8eb73bb1cd7afa7427049">bufferevent_setwatermark</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, short events, size_t lowmark, size_t highmark)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a56a61802037478591048b4967fa15599">bufferevent_lock</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a53fd135567d95cab72b8bad473c97510">bufferevent_unlock</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a03376a35668ff9b6dc905cce0d89876d">bufferevent_flush</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bufev, short iotype, enum <a class="el" href="bufferevent_8h.html#ac35edc760057a2e48b4e8ba9ecf2ad25">bufferevent_flush_mode</a> mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#af8932010b0a590ddf9848026e8a99059">bufferevent_pair_new</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, int options, struct <a class="el" href="structbufferevent.html">bufferevent</a> *pair[2])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a3ebd2a56a2ef87106bf76630eb0926b6">bufferevent_pair_get_partner</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structev__token__bucket__cfg.html">ev_token_bucket_cfg</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a60dd9d6469537b9099d2f6299c114ae6">ev_token_bucket_cfg_new</a> (size_t read_rate, size_t read_burst, size_t write_rate, size_t write_burst, const struct timeval *tick_len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#ad918ea1e7f7967e5db895c7dde5b78ae">ev_token_bucket_cfg_free</a> (struct <a class="el" href="structev__token__bucket__cfg.html">ev_token_bucket_cfg</a> *cfg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#aeb7bc9d8af4dd74b3de8dcd2941e6e02">bufferevent_set_rate_limit</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev, struct <a class="el" href="structev__token__bucket__cfg.html">ev_token_bucket_cfg</a> *cfg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <br class="typebreak"/>
<a class="el" href="structbufferevent__rate__limit__group.html">bufferevent_rate_limit_group</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#acf75d7e04a54e7fe4543f7efd596e7f7">bufferevent_rate_limit_group_new</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, const struct <a class="el" href="structev__token__bucket__cfg.html">ev_token_bucket_cfg</a> *cfg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a9b766efb61af2cb92d24f6e4caa38a53">bufferevent_rate_limit_group_set_cfg</a> (struct <a class="el" href="structbufferevent__rate__limit__group.html">bufferevent_rate_limit_group</a> *, const struct <a class="el" href="structev__token__bucket__cfg.html">ev_token_bucket_cfg</a> *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#aa2499cfb56976dcf3c6b846801043214">bufferevent_rate_limit_group_set_min_share</a> (struct <a class="el" href="structbufferevent__rate__limit__group.html">bufferevent_rate_limit_group</a> *, size_t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#adf4304c0c47fedb8122700ce1f0def8b">bufferevent_rate_limit_group_free</a> (struct <a class="el" href="structbufferevent__rate__limit__group.html">bufferevent_rate_limit_group</a> *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#aadb00f5d5c054bb705db78db327ef261">bufferevent_add_to_rate_limit_group</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev, struct <a class="el" href="structbufferevent__rate__limit__group.html">bufferevent_rate_limit_group</a> *g)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#abdbf64b4203fe6b65b263661ef18c6f2">bufferevent_remove_from_rate_limit_group</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2a8edb561655b13b013363726188f0c"></a><!-- doxytag: member="bufferevent.h::bufferevent_get_max_to_read" ref="ab2a8edb561655b13b013363726188f0c" args="(struct bufferevent *bev)" -->
ev_ssize_t&#160;</td><td class="memItemRight" valign="bottom"><b>bufferevent_get_max_to_read</b> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97487188a8ace977c3a74e330d2f224d"></a><!-- doxytag: member="bufferevent.h::bufferevent_get_max_to_write" ref="a97487188a8ace977c3a74e330d2f224d" args="(struct bufferevent *bev)" -->
ev_ssize_t&#160;</td><td class="memItemRight" valign="bottom"><b>bufferevent_get_max_to_write</b> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a4fec52eebbe5f925dfc2eaa60100124d">bufferevent_rate_limit_group_get_totals</a> (struct <a class="el" href="structbufferevent__rate__limit__group.html">bufferevent_rate_limit_group</a> *grp, ev_uint64_t *total_read_out, ev_uint64_t *total_written_out)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a38c81c84dc02318bd34f41d84f468a98">bufferevent_rate_limit_group_reset_totals</a> (struct <a class="el" href="structbufferevent__rate__limit__group.html">bufferevent_rate_limit_group</a> *grp)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Rate limit inspection</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Return the current read or write bucket size for a bufferevent. If it is not configured with a per-bufferevent ratelimit, return EV_SSIZE_MAX. This function does not inspect the group limit, if any. Note that it can return a negative value if the bufferevent has been made to read or write more than its limit. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73312a98fb1823be7936833a83b46a9d"></a><!-- doxytag: member="bufferevent.h::bufferevent_get_read_limit" ref="a73312a98fb1823be7936833a83b46a9d" args="(struct bufferevent *bev)" -->
ev_ssize_t&#160;</td><td class="memItemRight" valign="bottom"><b>bufferevent_get_read_limit</b> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90ee89498a9bd8777267fbca7947827d"></a><!-- doxytag: member="bufferevent.h::bufferevent_get_write_limit" ref="a90ee89498a9bd8777267fbca7947827d" args="(struct bufferevent *bev)" -->
ev_ssize_t&#160;</td><td class="memItemRight" valign="bottom"><b>bufferevent_get_write_limit</b> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Group Rate limit inspection</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Return the read or write bucket size for a bufferevent rate limit group. Note that it can return a negative value if bufferevents in the group have been made to read or write more than their limits. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa72d92d5179e24cd73a910fd353c927a"></a><!-- doxytag: member="bufferevent.h::bufferevent_rate_limit_group_get_read_limit" ref="aa72d92d5179e24cd73a910fd353c927a" args="(struct bufferevent_rate_limit_group *)" -->
ev_ssize_t&#160;</td><td class="memItemRight" valign="bottom"><b>bufferevent_rate_limit_group_get_read_limit</b> (struct <a class="el" href="structbufferevent__rate__limit__group.html">bufferevent_rate_limit_group</a> *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1f35e47760c34deaf1baede3fd0425a"></a><!-- doxytag: member="bufferevent.h::bufferevent_rate_limit_group_get_write_limit" ref="ad1f35e47760c34deaf1baede3fd0425a" args="(struct bufferevent_rate_limit_group *)" -->
ev_ssize_t&#160;</td><td class="memItemRight" valign="bottom"><b>bufferevent_rate_limit_group_get_write_limit</b> (struct <a class="el" href="structbufferevent__rate__limit__group.html">bufferevent_rate_limit_group</a> *)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Rate limit manipulation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Subtract a number of bytes from a bufferevent's read or write bucket. The decrement value can be negative, if you want to manually refill the bucket. If the change puts the bucket above or below zero, the bufferevent will resume or suspend reading writing as appropriate. These functions make no change in the buckets for the bufferevent's group, if any.</p>
<p>Returns 0 on success, -1 on internal error. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae22e5c618f1f93afcd6c2adb1b9ca165"></a><!-- doxytag: member="bufferevent.h::bufferevent_decrement_read_limit" ref="ae22e5c618f1f93afcd6c2adb1b9ca165" args="(struct bufferevent *bev, ev_ssize_t decr)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>bufferevent_decrement_read_limit</b> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev, ev_ssize_t decr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afedbe4264b84e4e8c65bdeba1bd42b6a"></a><!-- doxytag: member="bufferevent.h::bufferevent_decrement_write_limit" ref="afedbe4264b84e4e8c65bdeba1bd42b6a" args="(struct bufferevent *bev, ev_ssize_t decr)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>bufferevent_decrement_write_limit</b> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev, ev_ssize_t decr)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Group rate limit manipulation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Subtract a number of bytes from a bufferevent rate-limiting group's read or write bucket. The decrement value can be negative, if you want to manually refill the bucket. If the change puts the bucket above or below zero, the bufferevents in the group will resume or suspend reading writing as appropriate.</p>
<p>Returns 0 on success, -1 on internal error. </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5f603c05b36373b532db68aca645ed8"></a><!-- doxytag: member="bufferevent.h::bufferevent_rate_limit_group_decrement_read" ref="aa5f603c05b36373b532db68aca645ed8" args="(struct bufferevent_rate_limit_group *, ev_ssize_t)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>bufferevent_rate_limit_group_decrement_read</b> (struct <a class="el" href="structbufferevent__rate__limit__group.html">bufferevent_rate_limit_group</a> *, ev_ssize_t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec8e489e3c2705105d85064340018847"></a><!-- doxytag: member="bufferevent.h::bufferevent_rate_limit_group_decrement_write" ref="aec8e489e3c2705105d85064340018847" args="(struct bufferevent_rate_limit_group *, ev_ssize_t)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>bufferevent_rate_limit_group_decrement_write</b> (struct <a class="el" href="structbufferevent__rate__limit__group.html">bufferevent_rate_limit_group</a> *, ev_ssize_t)</td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Filtering support</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a19e499f7bfa831b802fd3575d141b4e1">bufferevent_filter_result</a> { <a class="el" href="bufferevent_8h.html#a19e499f7bfa831b802fd3575d141b4e1a794bf8211eaafdbeb382991dc5874e4d">BEV_OK</a> =  0, 
<a class="el" href="bufferevent_8h.html#a19e499f7bfa831b802fd3575d141b4e1a78c4f864aee50d333d74e3b46e12b8a4">BEV_NEED_MORE</a> =  1, 
<a class="el" href="bufferevent_8h.html#a19e499f7bfa831b802fd3575d141b4e1a4e51550811d3dad92400c27d69277032">BEV_ERROR</a> =  2
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef enum <br class="typebreak"/>
<a class="el" href="bufferevent_8h.html#a19e499f7bfa831b802fd3575d141b4e1">bufferevent_filter_result</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#a08a36463d040d1533ba3a06a5c776a99">bufferevent_filter_cb</a> )(struct <a class="el" href="structevbuffer.html">evbuffer</a> *src, struct <a class="el" href="structevbuffer.html">evbuffer</a> *dst, ev_ssize_t dst_limit, enum <a class="el" href="bufferevent_8h.html#ac35edc760057a2e48b4e8ba9ecf2ad25">bufferevent_flush_mode</a> mode, void *ctx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bufferevent_8h.html#ab6dea1351561f1866b0526fc1207bb69">bufferevent_filter_new</a> (struct <a class="el" href="structbufferevent.html">bufferevent</a> *underlying, <a class="el" href="bufferevent_8h.html#a08a36463d040d1533ba3a06a5c776a99">bufferevent_filter_cb</a> input_filter, <a class="el" href="bufferevent_8h.html#a08a36463d040d1533ba3a06a5c776a99">bufferevent_filter_cb</a> output_filter, int options, void(*free_context)(void *), void *ctx)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Functions for buffering data for network sending or receiving. Bufferevents are higher level than evbuffers: each has an underlying evbuffer for reading and one for writing, and callbacks that are invoked under certain circumstances.</p>
<p>A bufferevent provides input and output buffers that get filled and drained automatically. The user of a bufferevent no longer deals directly with the I/O, but instead is reading from input and writing to output buffers.</p>
<p>Once initialized, the bufferevent structure can be used repeatedly with <a class="el" href="bufferevent_8h.html#a1b9a3412e8c8e122c745b33d46b9643e">bufferevent_enable()</a> and <a class="el" href="bufferevent_8h.html#aa15582fe250247aa98d4897527215727">bufferevent_disable()</a>.</p>
<p>When reading is enabled, the bufferevent will try to read from the file descriptor onto its input buffer, and and call the read callback. When writing is enabled, the bufferevent will try to write data onto its file descriptor when writing is enabled, and call the write callback when the output buffer is sufficiently drained.</p>
<p>Bufferevents come in several flavors, including:</p>
<dl>
<dt>Socket-based bufferevents </dt>
<dd><p class="startdd">A bufferevent that reads and writes data onto a network socket. Created with <a class="el" href="bufferevent_8h.html#a501557193aa56c9f4923583d9d734395">bufferevent_socket_new()</a>.</p>
<p class="enddd"></p>
</dd>
<dt>Paired bufferevents </dt>
<dd><p class="startdd">A pair of bufferevents that send and receive data to one another without touching the network. Created with <a class="el" href="bufferevent_8h.html#af8932010b0a590ddf9848026e8a99059">bufferevent_pair_new()</a>.</p>
<p class="enddd"></p>
</dd>
<dt>Filtering bufferevents </dt>
<dd><p class="startdd">A bufferevent that transforms data, and sends or receives it over another underlying bufferevent. Created with <a class="el" href="bufferevent_8h.html#ab6dea1351561f1866b0526fc1207bb69">bufferevent_filter_new()</a>.</p>
<p class="enddd"></p>
</dd>
<dt>SSL-backed bufferevents </dt>
<dd>A bufferevent that uses the openssl library to send and receive data over an encrypted connection. Created with bufferevent_openssl_socket_new() or bufferevent_openssl_filter_new(). </dd>
</dl>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="affb7a7e5e21e1541ba6f43f950d92993"></a><!-- doxytag: member="bufferevent.h::BEV_EVENT_CONNECTED" ref="affb7a7e5e21e1541ba6f43f950d92993" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="bufferevent_8h.html#affb7a7e5e21e1541ba6f43f950d92993">BEV_EVENT_CONNECTED</a>&#160;&#160;&#160;0x80</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>connect operation finished. </p>

</div>
</div>
<a class="anchor" id="a4d7d8c93cf62e6f3d37c0cbac75aebcc"></a><!-- doxytag: member="bufferevent.h::BEV_EVENT_EOF" ref="a4d7d8c93cf62e6f3d37c0cbac75aebcc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="bufferevent_8h.html#a4d7d8c93cf62e6f3d37c0cbac75aebcc">BEV_EVENT_EOF</a>&#160;&#160;&#160;0x10</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>eof file reached </p>

</div>
</div>
<a class="anchor" id="a5f112d7a064258bdabf8d5182a3bf5e4"></a><!-- doxytag: member="bufferevent.h::BEV_EVENT_ERROR" ref="a5f112d7a064258bdabf8d5182a3bf5e4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="bufferevent_8h.html#a5f112d7a064258bdabf8d5182a3bf5e4">BEV_EVENT_ERROR</a>&#160;&#160;&#160;0x20</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>unrecoverable error encountered </p>

</div>
</div>
<a class="anchor" id="a504816ca8678e4f3d0bee2700fda524d"></a><!-- doxytag: member="bufferevent.h::BEV_EVENT_READING" ref="a504816ca8678e4f3d0bee2700fda524d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="bufferevent_8h.html#a504816ca8678e4f3d0bee2700fda524d">BEV_EVENT_READING</a>&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>error encountered while reading </p>

</div>
</div>
<a class="anchor" id="aa537428e3ac2c8d2dbb4ec041f09347f"></a><!-- doxytag: member="bufferevent.h::BEV_EVENT_TIMEOUT" ref="aa537428e3ac2c8d2dbb4ec041f09347f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="bufferevent_8h.html#aa537428e3ac2c8d2dbb4ec041f09347f">BEV_EVENT_TIMEOUT</a>&#160;&#160;&#160;0x40</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>user-specified timeout reached </p>

</div>
</div>
<a class="anchor" id="a557afaa0ce75e6bbb71fdcd68c35d077"></a><!-- doxytag: member="bufferevent.h::BEV_EVENT_WRITING" ref="a557afaa0ce75e6bbb71fdcd68c35d077" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="bufferevent_8h.html#a557afaa0ce75e6bbb71fdcd68c35d077">BEV_EVENT_WRITING</a>&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>error encountered while writing </p>

</div>
</div>
<a class="anchor" id="a78fc86349f408552be0fdf249db673ec"></a><!-- doxytag: member="bufferevent.h::EV_RATE_LIMIT_MAX" ref="a78fc86349f408552be0fdf249db673ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="bufferevent_8h.html#a78fc86349f408552be0fdf249db673ec">EV_RATE_LIMIT_MAX</a>&#160;&#160;&#160;EV_SSIZE_MAX</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum configurable rate- or burst-limit. </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a75e8fa059136e13c04c237e9c03cdbe8"></a><!-- doxytag: member="bufferevent.h::bufferevent_data_cb" ref="a75e8fa059136e13c04c237e9c03cdbe8" args=")(struct bufferevent *bev, void *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="bufferevent_8h.html#a75e8fa059136e13c04c237e9c03cdbe8">bufferevent_data_cb</a>)(struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev, void *ctx)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A read or write callback for a bufferevent.</p>
<p>The read callback is triggered when new data arrives in the input buffer and the amount of readable data exceed the low watermark which is 0 by default.</p>
<p>The write callback is triggered if the write buffer has been exhausted or fell below its low watermark.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bev</td><td>the bufferevent that triggered the callback </td></tr>
    <tr><td class="paramname">ctx</td><td>the user-specified context for this bufferevent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79b5f4b983f8e67005416738c6494ac6"></a><!-- doxytag: member="bufferevent.h::bufferevent_event_cb" ref="a79b5f4b983f8e67005416738c6494ac6" args=")(struct bufferevent *bev, short what, void *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="bufferevent_8h.html#a79b5f4b983f8e67005416738c6494ac6">bufferevent_event_cb</a>)(struct <a class="el" href="structbufferevent.html">bufferevent</a> *bev, short what, void *ctx)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>An event/error callback for a bufferevent.</p>
<p>The event callback is triggered if either an EOF condition or another unrecoverable error was encountered.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bev</td><td>the bufferevent for which the error condition was reached </td></tr>
    <tr><td class="paramname">what</td><td>a conjunction of flags: BEV_EVENT_READING or BEV_EVENT_WRITING to indicate if the error was encountered on the read or write path, and one of the following flags: BEV_EVENT_EOF, BEV_EVENT_ERROR, BEV_EVENT_TIMEOUT, BEV_EVENT_CONNECTED.</td></tr>
    <tr><td class="paramname">ctx</td><td>the user-specified context for this bufferevent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08a36463d040d1533ba3a06a5c776a99"></a><!-- doxytag: member="bufferevent.h::bufferevent_filter_cb" ref="a08a36463d040d1533ba3a06a5c776a99" args=")(struct evbuffer *src, struct evbuffer *dst, ev_ssize_t dst_limit, enum bufferevent_flush_mode mode, void *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="bufferevent_8h.html#a19e499f7bfa831b802fd3575d141b4e1">bufferevent_filter_result</a>(* <a class="el" href="bufferevent_8h.html#a08a36463d040d1533ba3a06a5c776a99">bufferevent_filter_cb</a>)(struct <a class="el" href="structevbuffer.html">evbuffer</a> *src, struct <a class="el" href="structevbuffer.html">evbuffer</a> *dst, ev_ssize_t dst_limit, enum <a class="el" href="bufferevent_8h.html#ac35edc760057a2e48b4e8ba9ecf2ad25">bufferevent_flush_mode</a> mode, void *ctx)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A callback function to implement a filter for a bufferevent.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>An evbuffer to drain data from. </td></tr>
    <tr><td class="paramname">dst</td><td>An evbuffer to add data to. </td></tr>
    <tr><td class="paramname">limit</td><td>A suggested upper bound of bytes to write to dst. The filter may ignore this value, but doing so means that it will overflow the high-water mark associated with dst. -1 means "no limit". </td></tr>
    <tr><td class="paramname">mode</td><td>Whether we should write data as may be convenient (BEV_NORMAL), or flush as much data as we can (BEV_FLUSH), or flush as much as we can, possibly including an end-of-stream marker (BEV_FINISH). </td></tr>
    <tr><td class="paramname">ctx</td><td>A user-supplied pointer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>BEV_OK if we wrote some data; BEV_NEED_MORE if we can't produce any more output until we get some input; and BEV_ERROR on an error. </dd></dl>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a19e499f7bfa831b802fd3575d141b4e1"></a><!-- doxytag: member="bufferevent.h::bufferevent_filter_result" ref="a19e499f7bfa831b802fd3575d141b4e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="bufferevent_8h.html#a19e499f7bfa831b802fd3575d141b4e1">bufferevent_filter_result</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Values that filters can return. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a19e499f7bfa831b802fd3575d141b4e1a794bf8211eaafdbeb382991dc5874e4d"></a><!-- doxytag: member="BEV_OK" ref="a19e499f7bfa831b802fd3575d141b4e1a794bf8211eaafdbeb382991dc5874e4d" args="" -->BEV_OK</em>&nbsp;</td><td>
<p>everything is okay </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a19e499f7bfa831b802fd3575d141b4e1a78c4f864aee50d333d74e3b46e12b8a4"></a><!-- doxytag: member="BEV_NEED_MORE" ref="a19e499f7bfa831b802fd3575d141b4e1a78c4f864aee50d333d74e3b46e12b8a4" args="" -->BEV_NEED_MORE</em>&nbsp;</td><td>
<p>the filter needs to read more data before output </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a19e499f7bfa831b802fd3575d141b4e1a4e51550811d3dad92400c27d69277032"></a><!-- doxytag: member="BEV_ERROR" ref="a19e499f7bfa831b802fd3575d141b4e1a4e51550811d3dad92400c27d69277032" args="" -->BEV_ERROR</em>&nbsp;</td><td>
<p>the filter encountered a critical error, no further data can be processed. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ac35edc760057a2e48b4e8ba9ecf2ad25"></a><!-- doxytag: member="bufferevent.h::bufferevent_flush_mode" ref="ac35edc760057a2e48b4e8ba9ecf2ad25" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="bufferevent_8h.html#ac35edc760057a2e48b4e8ba9ecf2ad25">bufferevent_flush_mode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flags that can be passed into filters to let them know how to deal with the incoming data. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ac35edc760057a2e48b4e8ba9ecf2ad25a81903ce04ca68ac1680dd0b7a28a7fce"></a><!-- doxytag: member="BEV_NORMAL" ref="ac35edc760057a2e48b4e8ba9ecf2ad25a81903ce04ca68ac1680dd0b7a28a7fce" args="" -->BEV_NORMAL</em>&nbsp;</td><td>
<p>usually set when processing data </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac35edc760057a2e48b4e8ba9ecf2ad25a77e7f15a95815dcaaef27fdabb0e6164"></a><!-- doxytag: member="BEV_FLUSH" ref="ac35edc760057a2e48b4e8ba9ecf2ad25a77e7f15a95815dcaaef27fdabb0e6164" args="" -->BEV_FLUSH</em>&nbsp;</td><td>
<p>want to checkpoint all data sent. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac35edc760057a2e48b4e8ba9ecf2ad25acb248a91854bbebd773061df7f4bbc94"></a><!-- doxytag: member="BEV_FINISHED" ref="ac35edc760057a2e48b4e8ba9ecf2ad25acb248a91854bbebd773061df7f4bbc94" args="" -->BEV_FINISHED</em>&nbsp;</td><td>
<p>encountered EOF on read or done sending data </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4919449c62c6483e2d135509190dc65"></a><!-- doxytag: member="bufferevent.h::bufferevent_options" ref="aa4919449c62c6483e2d135509190dc65" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="bufferevent_8h.html#aa4919449c62c6483e2d135509190dc65">bufferevent_options</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Options that can be specified when creating a bufferevent </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aa4919449c62c6483e2d135509190dc65a5dc89d74ef445da33295d00c8f6adc90"></a><!-- doxytag: member="BEV_OPT_CLOSE_ON_FREE" ref="aa4919449c62c6483e2d135509190dc65a5dc89d74ef445da33295d00c8f6adc90" args="" -->BEV_OPT_CLOSE_ON_FREE</em>&nbsp;</td><td>
<p>If set, we close the underlying file descriptor/bufferevent/whatever when this bufferevent is freed. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa4919449c62c6483e2d135509190dc65adfb637881b739eff1441ad848a5e3a2d"></a><!-- doxytag: member="BEV_OPT_THREADSAFE" ref="aa4919449c62c6483e2d135509190dc65adfb637881b739eff1441ad848a5e3a2d" args="" -->BEV_OPT_THREADSAFE</em>&nbsp;</td><td>
<p>If set, and threading is enabled, operations on this bufferevent are protected by a lock </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa4919449c62c6483e2d135509190dc65a2fbeb24d0156aa2492c23aaace73f1d3"></a><!-- doxytag: member="BEV_OPT_DEFER_CALLBACKS" ref="aa4919449c62c6483e2d135509190dc65a2fbeb24d0156aa2492c23aaace73f1d3" args="" -->BEV_OPT_DEFER_CALLBACKS</em>&nbsp;</td><td>
<p>If set, callbacks are run deferred in the event loop. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa4919449c62c6483e2d135509190dc65acb8ca6f6422fb8f9a748521cf8c4caf5"></a><!-- doxytag: member="BEV_OPT_UNLOCK_CALLBACKS" ref="aa4919449c62c6483e2d135509190dc65acb8ca6f6422fb8f9a748521cf8c4caf5" args="" -->BEV_OPT_UNLOCK_CALLBACKS</em>&nbsp;</td><td>
<p>If set, callbacks are executed without locks being held on the bufferevent. This option currently requires that BEV_OPT_DEFER_CALLBACKS also be set; a future version of Libevent might remove the requirement. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aadb00f5d5c054bb705db78db327ef261"></a><!-- doxytag: member="bufferevent.h::bufferevent_add_to_rate_limit_group" ref="aadb00f5d5c054bb705db78db327ef261" args="(struct bufferevent *bev, struct bufferevent_rate_limit_group *g)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="bufferevent_8h.html#aadb00f5d5c054bb705db78db327ef261">bufferevent_add_to_rate_limit_group</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbufferevent__rate__limit__group.html">bufferevent_rate_limit_group</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add 'bev' to the list of bufferevents whose aggregate reading and writing is restricted by 'g'. If 'g' is NULL, remove 'bev' from its current group.</p>
<p>A bufferevent may belong to no more than one rate-limit group at a time. If 'bev' is already a member of a group, it will be removed from its old group before being added to 'g'.</p>
<p>Return 0 on success and -1 on failure. </p>

</div>
</div>
<a class="anchor" id="a0697dabdb9b4057ae71b40a2f0e45fed"></a><!-- doxytag: member="bufferevent.h::bufferevent_base_set" ref="a0697dabdb9b4057ae71b40a2f0e45fed" args="(struct event_base *base, struct bufferevent *bufev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="bufferevent_8h.html#a0697dabdb9b4057ae71b40a2f0e45fed">bufferevent_base_set</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign a bufferevent to a specific <a class="el" href="structevent__base.html">event_base</a>.</p>
<p>NOTE that only socket bufferevents support this function.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>an <a class="el" href="structevent__base.html">event_base</a> returned by <a class="el" href="event__compat_8h.html#a1bf74386dd3725e1538fed2d70c1c113">event_init()</a> </td></tr>
    <tr><td class="paramname">bufev</td><td>a bufferevent struct returned by bufferevent_new() or <a class="el" href="bufferevent_8h.html#a501557193aa56c9f4923583d9d734395">bufferevent_socket_new()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bufferevent_new() </dd></dl>

</div>
</div>
<a class="anchor" id="aa15582fe250247aa98d4897527215727"></a><!-- doxytag: member="bufferevent.h::bufferevent_disable" ref="aa15582fe250247aa98d4897527215727" args="(struct bufferevent *bufev, short event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="bufferevent_8h.html#aa15582fe250247aa98d4897527215727">bufferevent_disable</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable a bufferevent.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent to be disabled </td></tr>
    <tr><td class="paramname">event</td><td>any combination of EV_READ | EV_WRITE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="bufferevent_8h.html#a1b9a3412e8c8e122c745b33d46b9643e">bufferevent_enable()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1b9a3412e8c8e122c745b33d46b9643e"></a><!-- doxytag: member="bufferevent.h::bufferevent_enable" ref="a1b9a3412e8c8e122c745b33d46b9643e" args="(struct bufferevent *bufev, short event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="bufferevent_8h.html#a1b9a3412e8c8e122c745b33d46b9643e">bufferevent_enable</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable a bufferevent.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent to be enabled </td></tr>
    <tr><td class="paramname">event</td><td>any combination of EV_READ | EV_WRITE. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="bufferevent_8h.html#aa15582fe250247aa98d4897527215727">bufferevent_disable()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab6dea1351561f1866b0526fc1207bb69"></a><!-- doxytag: member="bufferevent.h::bufferevent_filter_new" ref="ab6dea1351561f1866b0526fc1207bb69" args="(struct bufferevent *underlying, bufferevent_filter_cb input_filter, bufferevent_filter_cb output_filter, int options, void(*free_context)(void *), void *ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbufferevent.html">bufferevent</a>* <a class="el" href="bufferevent_8h.html#ab6dea1351561f1866b0526fc1207bb69">bufferevent_filter_new</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>underlying</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bufferevent_8h.html#a08a36463d040d1533ba3a06a5c776a99">bufferevent_filter_cb</a>&#160;</td>
          <td class="paramname"><em>input_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bufferevent_8h.html#a08a36463d040d1533ba3a06a5c776a99">bufferevent_filter_cb</a>&#160;</td>
          <td class="paramname"><em>output_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>free_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a new filtering bufferevent on top of an existing bufferevent.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">underlying</td><td>the underlying bufferevent. </td></tr>
    <tr><td class="paramname">input_filter</td><td>The filter to apply to data we read from the underlying bufferevent </td></tr>
    <tr><td class="paramname">output_filter</td><td>The filer to apply to data we write to the underlying bufferevent </td></tr>
    <tr><td class="paramname">options</td><td>A bitfield of bufferevent options. </td></tr>
    <tr><td class="paramname">free_context</td><td>A function to use to free the filter context when this bufferevent is freed. </td></tr>
    <tr><td class="paramname">ctx</td><td>A context pointer to pass to the filter functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03376a35668ff9b6dc905cce0d89876d"></a><!-- doxytag: member="bufferevent.h::bufferevent_flush" ref="a03376a35668ff9b6dc905cce0d89876d" args="(struct bufferevent *bufev, short iotype, enum bufferevent_flush_mode mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="bufferevent_8h.html#a03376a35668ff9b6dc905cce0d89876d">bufferevent_flush</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>iotype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="bufferevent_8h.html#ac35edc760057a2e48b4e8ba9ecf2ad25">bufferevent_flush_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Triggers the bufferevent to produce more data if possible.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent object </td></tr>
    <tr><td class="paramname">iotype</td><td>either EV_READ or EV_WRITE or both. </td></tr>
    <tr><td class="paramname">mode</td><td>either BEV_NORMAL or BEV_FLUSH or BEV_FINISHED </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-1 on failure, 0 if no data was produces, 1 if data was produced </dd></dl>

</div>
</div>
<a class="anchor" id="a474a4cef8fd80bea09a636b5f3055bec"></a><!-- doxytag: member="bufferevent.h::bufferevent_free" ref="a474a4cef8fd80bea09a636b5f3055bec" args="(struct bufferevent *bufev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="bufferevent_8h.html#a474a4cef8fd80bea09a636b5f3055bec">bufferevent_free</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deallocate the storage associated with a bufferevent structure.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent structure to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5cabb56040b43ba1a92efd21c4a89890"></a><!-- doxytag: member="bufferevent.h::bufferevent_get_base" ref="a5cabb56040b43ba1a92efd21c4a89890" args="(struct bufferevent *bev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structevent__base.html">event_base</a>* <a class="el" href="bufferevent_8h.html#a5cabb56040b43ba1a92efd21c4a89890">bufferevent_get_base</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bev</em></td><td>)</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the <a class="el" href="structevent__base.html">event_base</a> used by a bufferevent </p>

</div>
</div>
<a class="anchor" id="afbb4adabeb188cc9000bdee4ba23bdb2"></a><!-- doxytag: member="bufferevent.h::bufferevent_get_enabled" ref="afbb4adabeb188cc9000bdee4ba23bdb2" args="(struct bufferevent *bufev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short <a class="el" href="bufferevent_8h.html#afbb4adabeb188cc9000bdee4ba23bdb2">bufferevent_get_enabled</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the events that are enabled on a given bufferevent.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent to inspect </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A combination of EV_READ | EV_WRITE </dd></dl>

</div>
</div>
<a class="anchor" id="a7bc716ede3a5fc1e9107ae522e545e0c"></a><!-- doxytag: member="bufferevent.h::bufferevent_get_input" ref="a7bc716ede3a5fc1e9107ae522e545e0c" args="(struct bufferevent *bufev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structevbuffer.html">evbuffer</a>* <a class="el" href="bufferevent_8h.html#a7bc716ede3a5fc1e9107ae522e545e0c">bufferevent_get_input</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em></td><td>)</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the input buffer.</p>
<p>The user MUST NOT set the callback on this buffer.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent from which to get the evbuffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the evbuffer object for the input buffer </dd></dl>

</div>
</div>
<a class="anchor" id="af3dea057c5a276461dd94a1601682be1"></a><!-- doxytag: member="bufferevent.h::bufferevent_get_output" ref="af3dea057c5a276461dd94a1601682be1" args="(struct bufferevent *bufev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structevbuffer.html">evbuffer</a>* <a class="el" href="bufferevent_8h.html#af3dea057c5a276461dd94a1601682be1">bufferevent_get_output</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em></td><td>)</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the output buffer.</p>
<p>The user MUST NOT set the callback on this buffer.</p>
<p>When filters are being used, the filters need to be manually triggered if the output buffer was manipulated.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent from which to get the evbuffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the evbuffer object for the output buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a8d40fb7aea3c48e25d616bbe4b0fda65"></a><!-- doxytag: member="bufferevent.h::bufferevent_get_underlying" ref="a8d40fb7aea3c48e25d616bbe4b0fda65" args="(struct bufferevent *bufev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbufferevent.html">bufferevent</a>* <a class="el" href="bufferevent_8h.html#a8d40fb7aea3c48e25d616bbe4b0fda65">bufferevent_get_underlying</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em></td><td>)</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the underlying bufferevent associated with a bufferevent (if the bufferevent is a wrapper), or NULL if there is no underlying bufferevent. </p>

</div>
</div>
<a class="anchor" id="aa959659c8ba1c56c3444b5c147762a91"></a><!-- doxytag: member="bufferevent.h::bufferevent_getfd" ref="aa959659c8ba1c56c3444b5c147762a91" args="(struct bufferevent *bufev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> <a class="el" href="bufferevent_8h.html#aa959659c8ba1c56c3444b5c147762a91">bufferevent_getfd</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the file descriptor associated with a bufferevent, or -1 if no file descriptor is associated with the bufferevent. </p>

</div>
</div>
<a class="anchor" id="a56a61802037478591048b4967fa15599"></a><!-- doxytag: member="bufferevent.h::bufferevent_lock" ref="a56a61802037478591048b4967fa15599" args="(struct bufferevent *bufev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="bufferevent_8h.html#a56a61802037478591048b4967fa15599">bufferevent_lock</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acquire the lock on a bufferevent. Has no effect if locking was not enabled with BEV_OPT_THREADSAFE. </p>

</div>
</div>
<a class="anchor" id="a3ebd2a56a2ef87106bf76630eb0926b6"></a><!-- doxytag: member="bufferevent.h::bufferevent_pair_get_partner" ref="a3ebd2a56a2ef87106bf76630eb0926b6" args="(struct bufferevent *bev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbufferevent.html">bufferevent</a>* <a class="el" href="bufferevent_8h.html#a3ebd2a56a2ef87106bf76630eb0926b6">bufferevent_pair_get_partner</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bev</em></td><td>)</td>
          <td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Given one bufferevent returned by <a class="el" href="bufferevent_8h.html#af8932010b0a590ddf9848026e8a99059">bufferevent_pair_new()</a>, returns the other one if it still exists. Otherwise returns NULL. </p>

</div>
</div>
<a class="anchor" id="af8932010b0a590ddf9848026e8a99059"></a><!-- doxytag: member="bufferevent.h::bufferevent_pair_new" ref="af8932010b0a590ddf9848026e8a99059" args="(struct event_base *base, int options, struct bufferevent *pair[2])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="bufferevent_8h.html#af8932010b0a590ddf9848026e8a99059">bufferevent_pair_new</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>pair</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a pair of linked bufferevents. The bufferevents behave as would two bufferevent_sock instances connected to opposite ends of a socketpair(), except that no internal socketpair is allocated.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The event base to associate with the socketpair. </td></tr>
    <tr><td class="paramname">options</td><td>A set of options for this bufferevent </td></tr>
    <tr><td class="paramname">pair</td><td>A pointer to an array to hold the two new bufferevent objects. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a73e1daaa7c4d52c95b16c9944fa62e90"></a><!-- doxytag: member="bufferevent.h::bufferevent_priority_set" ref="a73e1daaa7c4d52c95b16c9944fa62e90" args="(struct bufferevent *bufev, int pri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="bufferevent_8h.html#a73e1daaa7c4d52c95b16c9944fa62e90">bufferevent_priority_set</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pri</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign a priority to a bufferevent.</p>
<p>Only supported for socket bufferevents.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>a bufferevent struct </td></tr>
    <tr><td class="paramname">pri</td><td>the priority to be assigned </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>

</div>
</div>
<a class="anchor" id="adf4304c0c47fedb8122700ce1f0def8b"></a><!-- doxytag: member="bufferevent.h::bufferevent_rate_limit_group_free" ref="adf4304c0c47fedb8122700ce1f0def8b" args="(struct bufferevent_rate_limit_group *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="bufferevent_8h.html#adf4304c0c47fedb8122700ce1f0def8b">bufferevent_rate_limit_group_free</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent__rate__limit__group.html">bufferevent_rate_limit_group</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Free a rate-limiting group. The group must have no members when this function is called. </p>

</div>
</div>
<a class="anchor" id="a4fec52eebbe5f925dfc2eaa60100124d"></a><!-- doxytag: member="bufferevent.h::bufferevent_rate_limit_group_get_totals" ref="a4fec52eebbe5f925dfc2eaa60100124d" args="(struct bufferevent_rate_limit_group *grp, ev_uint64_t *total_read_out, ev_uint64_t *total_written_out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="bufferevent_8h.html#a4fec52eebbe5f925dfc2eaa60100124d">bufferevent_rate_limit_group_get_totals</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent__rate__limit__group.html">bufferevent_rate_limit_group</a> *&#160;</td>
          <td class="paramname"><em>grp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_uint64_t *&#160;</td>
          <td class="paramname"><em>total_read_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_uint64_t *&#160;</td>
          <td class="paramname"><em>total_written_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inspect the total bytes read/written on a group.</p>
<p>Set the variable pointed to by total_read_out to the total number of bytes ever read on grp, and the variable pointed to by total_written_out to the total number of bytes ever written on grp. </p>

</div>
</div>
<a class="anchor" id="acf75d7e04a54e7fe4543f7efd596e7f7"></a><!-- doxytag: member="bufferevent.h::bufferevent_rate_limit_group_new" ref="acf75d7e04a54e7fe4543f7efd596e7f7" args="(struct event_base *base, const struct ev_token_bucket_cfg *cfg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbufferevent__rate__limit__group.html">bufferevent_rate_limit_group</a>* <a class="el" href="bufferevent_8h.html#acf75d7e04a54e7fe4543f7efd596e7f7">bufferevent_rate_limit_group_new</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structev__token__bucket__cfg.html">ev_token_bucket_cfg</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new rate-limit group for bufferevents. A rate-limit group constrains the maximum number of bytes sent and received, in toto, by all of its bufferevents.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>An <a class="el" href="structevent__base.html">event_base</a> to run any necessary timeouts for the group. Note that all bufferevents in the group do not necessarily need to share this <a class="el" href="structevent__base.html">event_base</a>. </td></tr>
    <tr><td class="paramname">cfg</td><td>The rate-limit for this group.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that all rate-limits hare are currently best-effort: future versions of Libevent may implement them more tightly.</p>
<p>Note also that only some bufferevent types currently respect rate-limiting. They are: socket-based bufferevents (normal and IOCP-based), and SSL-based bufferevents. </p>

</div>
</div>
<a class="anchor" id="a38c81c84dc02318bd34f41d84f468a98"></a><!-- doxytag: member="bufferevent.h::bufferevent_rate_limit_group_reset_totals" ref="a38c81c84dc02318bd34f41d84f468a98" args="(struct bufferevent_rate_limit_group *grp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="bufferevent_8h.html#a38c81c84dc02318bd34f41d84f468a98">bufferevent_rate_limit_group_reset_totals</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent__rate__limit__group.html">bufferevent_rate_limit_group</a> *&#160;</td>
          <td class="paramname"><em>grp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset the total bytes read/written on a group.</p>
<p>Reset the number of bytes read or written on grp as given by <a class="el" href="bufferevent_8h.html#a38c81c84dc02318bd34f41d84f468a98">bufferevent_rate_limit_group_reset_totals()</a>. </p>

</div>
</div>
<a class="anchor" id="a9b766efb61af2cb92d24f6e4caa38a53"></a><!-- doxytag: member="bufferevent.h::bufferevent_rate_limit_group_set_cfg" ref="a9b766efb61af2cb92d24f6e4caa38a53" args="(struct bufferevent_rate_limit_group *, const struct ev_token_bucket_cfg *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="bufferevent_8h.html#a9b766efb61af2cb92d24f6e4caa38a53">bufferevent_rate_limit_group_set_cfg</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent__rate__limit__group.html">bufferevent_rate_limit_group</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structev__token__bucket__cfg.html">ev_token_bucket_cfg</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the rate-limiting settings for a given rate-limiting group.</p>
<p>Return 0 on success, -1 on failure. </p>

</div>
</div>
<a class="anchor" id="aa2499cfb56976dcf3c6b846801043214"></a><!-- doxytag: member="bufferevent.h::bufferevent_rate_limit_group_set_min_share" ref="aa2499cfb56976dcf3c6b846801043214" args="(struct bufferevent_rate_limit_group *, size_t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="bufferevent_8h.html#aa2499cfb56976dcf3c6b846801043214">bufferevent_rate_limit_group_set_min_share</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent__rate__limit__group.html">bufferevent_rate_limit_group</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the smallest quantum we're willing to allocate to any single bufferevent in a group for reading or writing at a time.</p>
<p>The rationale is that, because of TCP/IP protocol overheads and kernel behavior, if a rate-limiting group is so tight on bandwidth that you're only willing to send 1 byte per tick per bufferevent, you might instead want to batch up the reads and writes so that you send N bytes per 1/N of the bufferevents (chosen at random) each tick, so you still wind up send 1 byte per tick per bufferevent on average, but you don't send so many tiny packets.</p>
<p>The default min-share is currently 64 bytes.</p>
<p>Returns 0 on success, -1 on faulre. </p>

</div>
</div>
<a class="anchor" id="a6bd435529e20a39b24fead9ddcd966ba"></a><!-- doxytag: member="bufferevent.h::bufferevent_read" ref="a6bd435529e20a39b24fead9ddcd966ba" args="(struct bufferevent *bufev, void *data, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="bufferevent_8h.html#a6bd435529e20a39b24fead9ddcd966ba">bufferevent_read</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read data from a bufferevent buffer.</p>
<p>The <a class="el" href="bufferevent_8h.html#a6bd435529e20a39b24fead9ddcd966ba">bufferevent_read()</a> function is used to read data from the input buffer.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent to be read from </td></tr>
    <tr><td class="paramname">data</td><td>pointer to a buffer that will store the data </td></tr>
    <tr><td class="paramname">size</td><td>the size of the data buffer, in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the amount of data read, in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2246fd48085c1acc9e98747a83af041"></a><!-- doxytag: member="bufferevent.h::bufferevent_read_buffer" ref="ab2246fd48085c1acc9e98747a83af041" args="(struct bufferevent *bufev, struct evbuffer *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="bufferevent_8h.html#ab2246fd48085c1acc9e98747a83af041">bufferevent_read_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read data from a bufferevent buffer into an evbuffer. This avoids memory copies.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent to be read from </td></tr>
    <tr><td class="paramname">buf</td><td>the evbuffer to which to add data </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred. </dd></dl>

</div>
</div>
<a class="anchor" id="abdbf64b4203fe6b65b263661ef18c6f2"></a><!-- doxytag: member="bufferevent.h::bufferevent_remove_from_rate_limit_group" ref="abdbf64b4203fe6b65b263661ef18c6f2" args="(struct bufferevent *bev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="bufferevent_8h.html#abdbf64b4203fe6b65b263661ef18c6f2">bufferevent_remove_from_rate_limit_group</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove 'bev' from its current rate-limit group (if any). </p>

</div>
</div>
<a class="anchor" id="aeb7bc9d8af4dd74b3de8dcd2941e6e02"></a><!-- doxytag: member="bufferevent.h::bufferevent_set_rate_limit" ref="aeb7bc9d8af4dd74b3de8dcd2941e6e02" args="(struct bufferevent *bev, struct ev_token_bucket_cfg *cfg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="bufferevent_8h.html#aeb7bc9d8af4dd74b3de8dcd2941e6e02">bufferevent_set_rate_limit</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structev__token__bucket__cfg.html">ev_token_bucket_cfg</a> *&#160;</td>
          <td class="paramname"><em>cfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the rate-limit of a the bufferevent 'bev' to the one specified in 'cfg'. If 'cfg' is NULL, disable any per-bufferevent rate-limiting on 'bev'.</p>
<p>Note that only some bufferevent types currently respect rate-limiting. They are: socket-based bufferevents (normal and IOCP-based), and SSL-based bufferevents.</p>
<p>Return 0 on sucess, -1 on failure. </p>

</div>
</div>
<a class="anchor" id="a3686d744e67e9a530ebf8ab888ade2cf"></a><!-- doxytag: member="bufferevent.h::bufferevent_set_timeouts" ref="a3686d744e67e9a530ebf8ab888ade2cf" args="(struct bufferevent *bufev, const struct timeval *timeout_read, const struct timeval *timeout_write)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="bufferevent_8h.html#a3686d744e67e9a530ebf8ab888ade2cf">bufferevent_set_timeouts</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timeval *&#160;</td>
          <td class="paramname"><em>timeout_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timeval *&#160;</td>
          <td class="paramname"><em>timeout_write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the read and write timeout for a bufferevent.</p>
<p>A bufferevent's timeout will fire the first time that the indicated amount of time has elapsed since a successful read or write operation, during which the bufferevent was trying to read or write.</p>
<p>(In other words, if reading or writing is disabled, or if the bufferevent's read or write operation has been suspended because there's no data to write, or not enough banwidth, or so on, the timeout isn't active. The timeout only becomes active when we we're willing to actually read or write.)</p>
<p>Calling bufferevent_enable or setting a timeout for a bufferevent whose timeout is already pending resets its timeout.</p>
<p>If the timeout elapses, the corresponding operation (EV_READ or EV_WRITE) becomes disabled until you re-enable it again. The bufferevent's event callback is called with the BEV_EVENT_TIMEOUT|BEV_EVENT_READING or BEV_EVENT_TIMEOUT|BEV_EVENT_WRITING.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent to be modified </td></tr>
    <tr><td class="paramname">timeout_read</td><td>the read timeout, or NULL </td></tr>
    <tr><td class="paramname">timeout_write</td><td>the write timeout, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63792519cb94a38beccb5e1390cd6198"></a><!-- doxytag: member="bufferevent.h::bufferevent_setcb" ref="a63792519cb94a38beccb5e1390cd6198" args="(struct bufferevent *bufev, bufferevent_data_cb readcb, bufferevent_data_cb writecb, bufferevent_event_cb eventcb, void *cbarg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="bufferevent_8h.html#a63792519cb94a38beccb5e1390cd6198">bufferevent_setcb</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bufferevent_8h.html#a75e8fa059136e13c04c237e9c03cdbe8">bufferevent_data_cb</a>&#160;</td>
          <td class="paramname"><em>readcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bufferevent_8h.html#a75e8fa059136e13c04c237e9c03cdbe8">bufferevent_data_cb</a>&#160;</td>
          <td class="paramname"><em>writecb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bufferevent_8h.html#a79b5f4b983f8e67005416738c6494ac6">bufferevent_event_cb</a>&#160;</td>
          <td class="paramname"><em>eventcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>cbarg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Changes the callbacks for a bufferevent.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent object for which to change callbacks </td></tr>
    <tr><td class="paramname">readcb</td><td>callback to invoke when there is data to be read, or NULL if no callback is desired </td></tr>
    <tr><td class="paramname">writecb</td><td>callback to invoke when the file descriptor is ready for writing, or NULL if no callback is desired </td></tr>
    <tr><td class="paramname">eventcb</td><td>callback to invoke when there is an event on the file descriptor </td></tr>
    <tr><td class="paramname">cbarg</td><td>an argument that will be supplied to each of the callbacks (readcb, writecb, and errorcb) </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bufferevent_new() </dd></dl>

</div>
</div>
<a class="anchor" id="a0a367e404942c11265bfcd0b693aa120"></a><!-- doxytag: member="bufferevent.h::bufferevent_setfd" ref="a0a367e404942c11265bfcd0b693aa120" args="(struct bufferevent *bufev, evutil_socket_t fd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="bufferevent_8h.html#a0a367e404942c11265bfcd0b693aa120">bufferevent_setfd</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Changes the file descriptor on which the bufferevent operates. Not supported for all bufferevent types.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent object for which to change the file descriptor </td></tr>
    <tr><td class="paramname">fd</td><td>the file descriptor to operate on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74e3835e99f8eb73bb1cd7afa7427049"></a><!-- doxytag: member="bufferevent.h::bufferevent_setwatermark" ref="a74e3835e99f8eb73bb1cd7afa7427049" args="(struct bufferevent *bufev, short events, size_t lowmark, size_t highmark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="bufferevent_8h.html#a74e3835e99f8eb73bb1cd7afa7427049">bufferevent_setwatermark</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>events</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lowmark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>highmark</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the watermarks for read and write events.</p>
<p>On input, a bufferevent does not invoke the user read callback unless there is at least low watermark data in the buffer. If the read buffer is beyond the high watermark, the bufferevent stops reading from the network.</p>
<p>On output, the user write callback is invoked whenever the buffered data falls below the low watermark. Filters that write to this bufev will try not to write more bytes to this buffer than the high watermark would allow, except when flushing.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent to be modified </td></tr>
    <tr><td class="paramname">events</td><td>EV_READ, EV_WRITE or both </td></tr>
    <tr><td class="paramname">lowmark</td><td>the lower watermark to set </td></tr>
    <tr><td class="paramname">highmark</td><td>the high watermark to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2ecbb906883ea848f7bca767d479a2a"></a><!-- doxytag: member="bufferevent.h::bufferevent_socket_connect" ref="ac2ecbb906883ea848f7bca767d479a2a" args="(struct bufferevent *, struct sockaddr *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="bufferevent_8h.html#ac2ecbb906883ea848f7bca767d479a2a">bufferevent_socket_connect</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Launch a connect() attempt with a socket-based bufferevent.</p>
<p>When the connect succeeds, the eventcb will be invoked with BEV_EVENT_CONNECTED set.</p>
<p>If the bufferevent does not already have a socket set, we allocate a new socket here and make it nonblocking before we begin.</p>
<p>If no address is provided, we assume that the socket is already connecting, and configure the bufferevent so that a BEV_EVENT_CONNECTED event will be yielded when it is done connecting.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>an existing bufferevent allocated with <a class="el" href="bufferevent_8h.html#a501557193aa56c9f4923583d9d734395">bufferevent_socket_new()</a>. </td></tr>
    <tr><td class="paramname">addr</td><td>the address we should connect to </td></tr>
    <tr><td class="paramname">socklen</td><td>The length of the address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a797686b522045aefb217c6b87ea7ae4a"></a><!-- doxytag: member="bufferevent.h::bufferevent_socket_connect_hostname" ref="a797686b522045aefb217c6b87ea7ae4a" args="(struct bufferevent *, struct evdns_base *, int, const char *, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="bufferevent_8h.html#a797686b522045aefb217c6b87ea7ae4a">bufferevent_socket_connect_hostname</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevdns__base.html">evdns_base</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resolve the hostname 'hostname' and connect to it as with <a class="el" href="bufferevent_8h.html#ac2ecbb906883ea848f7bca767d479a2a">bufferevent_socket_connect()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>An existing bufferevent allocated with <a class="el" href="bufferevent_8h.html#a501557193aa56c9f4923583d9d734395">bufferevent_socket_new()</a> </td></tr>
    <tr><td class="paramname"><a class="el" href="structevdns__base.html">evdns_base</a></td><td>Optionally, an <a class="el" href="structevdns__base.html">evdns_base</a> to use for resolving hostnames asynchronously. May be set to NULL for a blocking resolve. </td></tr>
    <tr><td class="paramname">family</td><td>A preferred address family to resolve addresses to, or AF_UNSPEC for no preference. Only AF_INET, AF_INET6, and AF_UNSPEC are supported. </td></tr>
    <tr><td class="paramname">hostname</td><td>The hostname to resolve; see below for notes on recognized formats </td></tr>
    <tr><td class="paramname">port</td><td>The port to connect to on the resolved address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, -1 on failure.</dd></dl>
<p>Recognized hostname formats are:</p>
<p>www.example.com (hostname) 1.2.3.4 (ipv4address) ::1 (ipv6address) [::1] ([ipv6address])</p>
<p>Performance note: If you do not provide an <a class="el" href="structevdns__base.html">evdns_base</a>, this function may block while it waits for a DNS response. This is probably not what you want. </p>

</div>
</div>
<a class="anchor" id="a9a66b02bce652cdbcc7d26636ce26d67"></a><!-- doxytag: member="bufferevent.h::bufferevent_socket_get_dns_error" ref="a9a66b02bce652cdbcc7d26636ce26d67" args="(struct bufferevent *bev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="bufferevent_8h.html#a9a66b02bce652cdbcc7d26636ce26d67">bufferevent_socket_get_dns_error</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the error code for the last failed DNS lookup attempt made by <a class="el" href="bufferevent_8h.html#a797686b522045aefb217c6b87ea7ae4a">bufferevent_socket_connect_hostname()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bev</td><td>The bufferevent object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>DNS error code. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>evutil_gai_strerror() </dd></dl>

</div>
</div>
<a class="anchor" id="a501557193aa56c9f4923583d9d734395"></a><!-- doxytag: member="bufferevent.h::bufferevent_socket_new" ref="a501557193aa56c9f4923583d9d734395" args="(struct event_base *base, evutil_socket_t fd, int options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structbufferevent.html">bufferevent</a>* <a class="el" href="bufferevent_8h.html#a501557193aa56c9f4923583d9d734395">bufferevent_socket_new</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new socket bufferevent over an existing socket.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the event base to associate with the new bufferevent. </td></tr>
    <tr><td class="paramname">fd</td><td>the file descriptor from which data is read and written to. This file descriptor is not allowed to be a pipe(2). It is safe to set the fd to -1, so long as you later set it with bufferevent_setfd or <a class="el" href="bufferevent_8h.html#ac2ecbb906883ea848f7bca767d479a2a">bufferevent_socket_connect()</a>. </td></tr>
    <tr><td class="paramname">options</td><td>Zero or more BEV_OPT_* flags </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a pointer to a newly allocated bufferevent struct, or NULL if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="bufferevent_8h.html#a474a4cef8fd80bea09a636b5f3055bec">bufferevent_free()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a53fd135567d95cab72b8bad473c97510"></a><!-- doxytag: member="bufferevent.h::bufferevent_unlock" ref="a53fd135567d95cab72b8bad473c97510" args="(struct bufferevent *bufev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="bufferevent_8h.html#a53fd135567d95cab72b8bad473c97510">bufferevent_unlock</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release the lock on a bufferevent. Has no effect if locking was not enabled with BEV_OPT_THREADSAFE. </p>

</div>
</div>
<a class="anchor" id="abc606695cd6bb2e3f25c4330d0c9e3ab"></a><!-- doxytag: member="bufferevent.h::bufferevent_write" ref="abc606695cd6bb2e3f25c4330d0c9e3ab" args="(struct bufferevent *bufev, const void *data, size_t size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="bufferevent_8h.html#abc606695cd6bb2e3f25c4330d0c9e3ab">bufferevent_write</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write data to a bufferevent buffer.</p>
<p>The <a class="el" href="bufferevent_8h.html#abc606695cd6bb2e3f25c4330d0c9e3ab">bufferevent_write()</a> function can be used to write data to the file descriptor. The data is appended to the output buffer and written to the descriptor automatically as it becomes available for writing.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent to be written to </td></tr>
    <tr><td class="paramname">data</td><td>a pointer to the data to be written </td></tr>
    <tr><td class="paramname">size</td><td>the length of the data, in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="bufferevent_8h.html#a3b140a32a4d16c402433130dc8c3bde4">bufferevent_write_buffer()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3b140a32a4d16c402433130dc8c3bde4"></a><!-- doxytag: member="bufferevent.h::bufferevent_write_buffer" ref="a3b140a32a4d16c402433130dc8c3bde4" args="(struct bufferevent *bufev, struct evbuffer *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="bufferevent_8h.html#a3b140a32a4d16c402433130dc8c3bde4">bufferevent_write_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structbufferevent.html">bufferevent</a> *&#160;</td>
          <td class="paramname"><em>bufev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structevbuffer.html">evbuffer</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write data from an evbuffer to a bufferevent buffer. The evbuffer is being drained as a result.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">bufev</td><td>the bufferevent to be written to </td></tr>
    <tr><td class="paramname">buf</td><td>the evbuffer to be written </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if successful, or -1 if an error occurred </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="bufferevent_8h.html#abc606695cd6bb2e3f25c4330d0c9e3ab">bufferevent_write()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad918ea1e7f7967e5db895c7dde5b78ae"></a><!-- doxytag: member="bufferevent.h::ev_token_bucket_cfg_free" ref="ad918ea1e7f7967e5db895c7dde5b78ae" args="(struct ev_token_bucket_cfg *cfg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="bufferevent_8h.html#ad918ea1e7f7967e5db895c7dde5b78ae">ev_token_bucket_cfg_free</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structev__token__bucket__cfg.html">ev_token_bucket_cfg</a> *&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Free all storage held in 'cfg'.</p>
<p>Note: 'cfg' is not currently reference-counted; it is not safe to free it until no bufferevent is using it. </p>

</div>
</div>
<a class="anchor" id="a60dd9d6469537b9099d2f6299c114ae6"></a><!-- doxytag: member="bufferevent.h::ev_token_bucket_cfg_new" ref="a60dd9d6469537b9099d2f6299c114ae6" args="(size_t read_rate, size_t read_burst, size_t write_rate, size_t write_burst, const struct timeval *tick_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structev__token__bucket__cfg.html">ev_token_bucket_cfg</a>* <a class="el" href="bufferevent_8h.html#a60dd9d6469537b9099d2f6299c114ae6">ev_token_bucket_cfg_new</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>read_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>read_burst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>write_rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>write_burst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timeval *&#160;</td>
          <td class="paramname"><em>tick_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize and return a new object to configure the rate-limiting behavior of bufferevents.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">read_rate</td><td>The maximum number of bytes to read per tick on average. </td></tr>
    <tr><td class="paramname">read_burst</td><td>The maximum number of bytes to read in any single tick. </td></tr>
    <tr><td class="paramname">write_rate</td><td>The maximum number of bytes to write per tick on average. </td></tr>
    <tr><td class="paramname">write_burst</td><td>The maximum number of bytes to write in any single tick. </td></tr>
    <tr><td class="paramname">tick_len</td><td>The length of a single tick. Defaults to one second. Any fractions of a millisecond are ignored.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that all rate-limits hare are currently best-effort: future versions of Libevent may implement them more tightly. </p>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 17 2014 22:16:07 for lldp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
